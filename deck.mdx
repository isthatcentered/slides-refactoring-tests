import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {Image, Appear} from 'mdx-deck'
import { github, vsDark, shadesOfPurple, base } from "@code-surfer/themes";
import ciFailBadNamingSrc from "./static/test_with_bad_naming_run_fail.png"
import image from "./src/components/image"
import TestReport, { Matchers } from "./src/components/test-report"
import Section  from "./src/components/section"
import Sections  from "./src/components/sections"
import Banner  from "./src/components/banner"
import {HardToNavigateRefactors, UnclearRefactors, UselessFailureRefactors, BrokenButWorkingRefactors}  from "./src/components/refactor-table"
import Chapter  from "./src/components/chapter"
import SplitBA  from "./src/components/split"
import {Inline, Caption, Figure, EmojiSlide, TestsVsDevKnowledgeTable } from "./src/components"
import "./src/styles.css"
import SlidesTheme from "./src/theme.js"
import "typeface-gothic-a1"
import videoCapSrc from "./static/video_cap.jpg"
export const theme = SlidesTheme

export const splitCodeSampleProps = {themes: [vsDark , theme]}

export const FunFact = () => <div>Also</div>;
  

# 👋🌏

---

<EmojiSlide caption="Clean code">
🛀📝
</EmojiSlide>  

<Notes>

- Dur passer jour sans entendre parler clean code
- Article, livre, collegue, video, ... 
- Tous jours pappel importance

</Notes>

---

<EmojiSlide caption="Our code">  
    <span>🤱</span>
    <Appear>
        <span key="1">🤏</span>
        <span key="2">👶</span>
        <span key="3">🌹</span>
    </Appear>
</EmojiSlide>


<Notes>

- Prendre soin code
- Méthodes courtes
- Renommer methodes, class, variable 
- Jusqu''à ce que ça se lise comme poésie
- Et puis pourtants fichiers test:

</Notes>

---

<CodeSurfer>

```ts showNumbers
test("<Signup/>", async () => {
    const navigateSpy = jest.fn()
    ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
        () => navigateSpy,
    )
    ;((User.createUser as any) as jest.MockInstance<
        ReturnType<typeof User.createUser>,
        any
    >).mockResolvedValue(null as any)
    ;((SocialLogin as any) as jest.MockInstance<
        ReturnType<typeof SocialLogin>,
        any
    >).mockImplementation(() => null)
    
    const page = render(<Signin />)
    
    const submitButton = page.getByRole("button", {
        name: /signin/i,
    }) as HTMLButtonElement
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Login & password required/i)).not.toThrow()
    
    const email = page.getByLabelText(/email/i)
    fireEvent.change(email, { target: { value: "john@gmail.com" } })
    
    const password = page.getByLabelText(/password/i)
    fireEvent.change(password, { target: { value: "helloworld" } })
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Loading/i)).not.toThrow()
    expect(submitButton.disabled).toBe(true)
    
    expect(User.createUser).toHaveBeenCalledWith({
        email: "john@gmail.com",
        password: "helloworld",
    })
    
    await tick()
    
    expect(navigateSpy).toHaveBeenCalledWith("/")
    
    expect(SocialLogin).toHaveBeenLastCalledWith(
        {
            loginEnpointRootUrl: API_BASE_URL,
        } as PropsType<typeof SocialLogin>,
        {},
    )

    // ... more
})
```

</CodeSurfer>

---

<EmojiSlide caption="I quit">  
    🏃‍♂️
</EmojiSlide>

<Notes>

- Moment ou souvient 18h, piscine, time to go home

</Notes>


---

# Refactoring tests

---

<img style={{"width":"650px",}} alt="" src="https://www.bordeauxmecenes.org/wp-content/uploads/2019/11/zenikalogo.png"/>

## <b style={{color: theme.colors.primaryDark, marginTop: -100, display: "block"}}>Edouard Penin</b>

<Notes>

<div style={{"display":"flex","justifyContent":"center","alignItems":"center","marginTop":"-40px","color":"#888888",}}>
    <img style={{"width":"60px","marginRight":".25em"}} alt="" src="https://upload.wikimedia.org/wikipedia/fr/thumb/c/c8/Twitter_Bird.svg/1200px-Twitter_Bird.svg.png"/>
    @isthatcentered
</div>

- Edouard Penin
- Consultant/formateur zenika nantes
- Pourquoi là pour vous parler tests ?
- Parce que passé beaucoup plus de temps que justifié à réfléchir à toutes ces questions
- Et puis à travers personnes formées,
- Veut pas dire toujours raison/pas mieux que ce que propose
- teams/applis/clients travaillé (tout petits et très grands)
- Pas mal de choses à partager et assez retours experience pour reconnaitre/prévoir avantages et inconvénients solution celon contexte

</Notes>

---

<EmojiSlide caption="Refactoring tests ?">
🧐
</EmojiSlide>  


<Notes>

- Why
- J'ai des tests c'et pas suffisant ?

</Notes>

---



<EmojiSlide caption="A test suite is a runnable specification">
🏃‍♂️✅
</EmojiSlide>  

<Notes>

- Spécification executable
- AKA feedback constant, immédiat et automatique bon fonctionement appli à chaque changement
- Source de vérité:
    - Comment chaque ecran app doit se comporter
    - comment chaque edge case doit être géré

</Notes>

---

<EmojiSlide caption="Watches over the whole application so that you don't have to">
🌍🕵️‍♂️
</EmojiSlide>

<Notes>

- Lors ajout feature/refactor
- Permet concentrer / feature only
- Oublier reste
- Partenaire en pair pro
    - Là pour faire singe si cassé truc à l'autre bout appli avec dernier changement
    - Peux ajuster stratégie immédiatement, pas après 10 jours de dev sur feature

</Notes>

---


<TestsVsDevKnowledgeTable dev="🧩" tests="📚📚📚" result="😀" />

<Notes>

- Parait idéal, 
- As dev, meilleur journée bc charge mentale --
- As team, livrer + features + vite avec + qualité 
- bc filet/guardien autour nous évite tout un cycle dpeloy -> QA si créé bug


- Ca = dans l'ideal
- pb arrive qd deadline approche
- Deadline = pression = stress
- Donc why refacto/prendre soin tests/dépenser temps à rendre plus compréhensibles ?
- Tests font pas tourner appli, pas vitaux pour fonctionner
- donc si ils m'empêchent d'avancer vite 
    - bc dur comprendre
    - dois réécrire tout test bc changé nom de var dans code
- ils sautent
- Il justifient pas leur poid
- Et pb avec test en moins

</Notes>

---

<TestsVsDevKnowledgeTable dev="📚🧩" tests="📚📚" result="😐" />

<Notes>

- Test en moins = pièce en plus en tête
- Doit gérer feature + effet de bord code non testé
- Tests = spec auto. Mais plus tests. DOnc,
- Doit connaitre par coeur toutes règles/edges cases de autre feature 
- Et verif manuellement
- Pourquoi pas, fun si nouveau dev
- Inertie créée

</Notes>

---

<TestsVsDevKnowledgeTable dev="📚📚🧩" tests="📚" result="😕" />

<Notes>

- Facile ajouter test quand tout déjà prêt
- Dur quand moitié tests marchent pas
- + en + barrières à dépasser pour écrire test
- Demande + en + énergie
- Du coup - en - tests écris

</Notes>

---

<TestsVsDevKnowledgeTable dev="📚📚📚🧩" tests="" result="😵" />

<Notes>

- EN gros, arrive moment ou
- Plus de test/plus confiance
- A chaque changement doit tout vérifier
- impossible toute app en tête
- 2 pas arrières pour 1 en avant
- J'ajoute truc -> casse deux 

</Notes>

---

<EmojiSlide>
    <span>
        😤 
    </span>
    <Appear>
        <span>
        😤 
        </span>
        <span>💸</span>
        <span>👎</span>
    </Appear>
</EmojiSlide>

<Notes>

- Traduit par
- Equipe frustrée (dev/business)
- ++ bugs donc users frustrés
- lost money
- Credibility
- but aujourd'hui: 

</Notes>

---

<EmojiSlide>
    <span>
    👃
    </span>
    <Appear>
     <span>→ 👷‍♂️</span>
    </Appear>
</EmojiSlide>
  
<Notes>

- Identifier smells qui font test difficile maintenir
- Voir pistes pour faire mieux
- combo smell -> refactor
- POur que, dans periodes stress
- Ajouter/modifier test soit facile
- Mieux, tests aident à faire évoluer appli

</Notes>

---


<img style={{maxWidth: 500}} src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Unofficial_JavaScript_logo_2.svg/1200px-Unofficial_JavaScript_logo_2.svg.png"/> 

<Notes>

- Examples en js mais adapateble à tout
- Examples simple
- important = principe idée derrière le refactor

</Notes>

   
<!-- 
🏗 + 💯 + 👌 + 🤸‍
- Structure 🏗
- Expressiveness 💯
- Feedback 👌
- Flexibility 🤸‍
-->

---

<!--
*****************************************************************************
*****************************************************************************
** Hard to navigate *********************************************************
*****************************************************************************
*****************************************************************************
-->

<Sections active={0}/>

<Notes>

- Difficile à naviguer



- Veut contribution facile sous pression

- Impossible si chaque test réinvente la roue (naming, organisation, strategie)



- Objectifs:

- Réduire friction

- Trouver moyen tests ressemblent

- Le sujet du test sera tjs different

- Mais au niveau etapes, methode, visuellement, veut chaque test soit familié mm si ouvert premiere fois

</Notes>

--- 

<EmojiSlide>🙋‍♂️</EmojiSlide>

<Notes>

- Pas besoin lire code
- Dur à comprendre, c'est but
- moi guide

</Notes>

---

<!--
****************************
****************************
** 👃 All in one
****************************
****************************
-->

<Chapter emojis="👨‍👩‍👧‍👦" title="All in one" />

<Notes>

- Premier dans categorie dur à naviguer
- Tout en un

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->
 
<CodeSurfer>

```js showNumbers
test("<LoginPage/>", () => {
  // ...
}) 
```

```js showNumbers
test("<LoginPage/>", () => {
  /const navigateSpy = jest.fn()
  ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
    () => navigateSpy,
  )
  ;((User.createUser as any) as jest.MockInstance<
  ReturnType<typeof User.createUser>,
  any
  >).mockResolvedValue(null as any)
  ;((SocialLogin as any) as jest.MockInstance<
  ReturnType<typeof SocialLogin>,
  any
  >).mockImplementation(() => null)
  
  const page = render(<Signin />)
  
  const submitButton = page.getByRole("button", {
    name: /signin/i,
  }) as HTMLButtonElement
  
  fireEvent.click(submitButton)
  
  expect(() => page.getByText(/Login & password required/i)).not.toThrow()
  
  const email = page.getByLabelText(/email/i)
  fireEvent.change(email, { target: { value: "john@gmail.com" } })
  
  const password = page.getByLabelText(/password/i)
  fireEvent.change(password, { target: { value: "helloworld" } })
  
  fireEvent.click(submitButton)
  
  expect(() => page.getByText(/Loading/i)).not.toThrow()
  expect(submitButton.disabled).toBe(true)
  
  expect(User.createUser).toHaveBeenCalledWith({
    email: "john@gmail.com",
    password: "helloworld",
  })
  
  await tick()
  
  expect(navigateSpy).toHaveBeenCalledWith("/")
  
  expect(SocialLogin).toHaveBeenLastCalledWith(
    {
      loginEnpointRootUrl: API_BASE_URL,
    } as PropsType<typeof SocialLogin>,
    {},
)
  
  // ... more
}) 
```

</CodeSurfer>

<Notes>

- Juste 1 test pour toute page ?
- verification validation/redirection/loading state, etc ?
  

- [Dump ensemble cas tests pour page]
- Quoi pb ?
    - Fait peur
    - Surface à apprendre très large
    - Etapes probablement inter-dépendantes (je bouge A, je casse D et sais pas pkoi)
- Imaginez si faut ajouter nouveau cas...

- Coomment mieux ?
- Au lieu test géant, ensemble petits tests dédiés à scénario précis

</Notes>

---

<CodeSurfer>

```js 1[6:39] showNumbers
test("method -> condition -> behavior", ()=> {})
```

```js 1[6:18] showNumbers
test("<LoginPage/> -> condition -> behavior", ()=> {})
```

```js 1[23:35],2 showNumbers
test("<LoginPage/> -> condition -> behavior", ()=> {
  expect(() => page.getByText("Mot de passe ou nom d'utilisateur invalide")).not.toThrow()
})
```


```js 1[23:35] showNumbers
test("<LoginPage/> -> failed login -> behavior", ()=> {
  expect(() => page.getByText("Mot de passe ou nom d'utilisateur invalide")).not.toThrow()
})
```

```js 1[38:46] showNumbers
test("<LoginPage/> -> failed login -> behavior", ()=> {
  expect(() => page.getByText("Mot de passe ou nom d'utilisateur invalide")).not.toThrow()
})
```

```js 1[39:60] showNumbers
test("<LoginPage/> -> failed login -> displays server error", ()=> {
  expect(() => page.getByText("Mot de passe ou nom d'utilisateur invalide")).not.toThrow()
})
```

```js 1[7:54] showNumbers
test("<LoginPage/> failed login displays server error", ()=> {
  expect(() => page.getByText("Mot de passe ou nom d'utilisateur invalide")).not.toThrow()
})
```


```js 2:6 showNumbers
describe("<LoginPage/>", () => {
  describe("Failed login", () => {
    test("Displays server error", ()=>{})
    test("Requires captcha on subsequent attempts", ()=>{})
    //...
  }) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

</CodeSurfer>

<Notes>

- Aider convention nommage
- Donne framework pour découper tests et mm découvrir scénarios pas pensé
- Propose celle là mais pleins d'autres, pouvez mm l'inventer, 
- L'important = parle/aide à écrire tests/critères acceptance 


- [methode] -> sujet du test (repo.add/createUser/...) 
- [Contition] 
- remonter partie code précédent pour concret
- -> qu'est-ce qui rend ce test spécial (pré-condition qui rend scénario spécial)  
- [login failed]
- [Comportement] = résultat suite condition
- [afficher erreur serveur]
- [Etant donnée login échoué, blah blah blah]
  
- [plusieurs cas possibles par condition (might be another condition)]
- séparation pré-condition (describe)/test (test) peut aider à se poser question

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 FUNFACT START 👈 -->

<FunFact/>

<Notes>

- Aussi, bénéfice,
- Avant renommage si fail pb validation:

</Notes>

---

<TestReport name="<LoginPage/>" >
    <span style={{color:"lightgray"}}>// Some random error</span>
</TestReport>

<Notes>

- "login page cassée"
- Redirection ?
- Error message ? 
- Yup
- Pendant refactor, perte flow

</Notes>

---

<TestReport name="<LoginPage/> Successful login redirects to dashboard" >
    <span style={{color:"lightgray"}}>// Some error that makes more sense now</span>
</TestReport>

<Notes>

- Bon nom test = quel est pb
- Lancer investigations
- Pas besoin débugger test pour débugger appli

</Notes>

<!-- 👉 FUNFACT END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns  {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="before"
test("<LoginPage/>", () => {
  /const navigateSpy = jest.fn()
  ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
    () => navigateSpy,
  )
  ;((User.createUser as any) as jest.MockInstance<
  ReturnType<typeof User.createUser>,
  any
  >).mockResolvedValue(null as any)
  ;((SocialLogin as any) as jest.MockInstance<
  ReturnType<typeof SocialLogin>,
  any
  >).mockImplementation(() => null)
  
  const page = render(<Signin />)
  
  const submitButton = page.getByRole("button", {
    name: /signin/i,
  }) as HTMLButtonElement
  
  fireEvent.click(submitButton)
  
  expect(() => page.getByText(/Login & password required/i)).not.toThrow()
  
  const email = page.getByLabelText(/email/i)
  fireEvent.change(email, { target: { value: "john@gmail.com" } })
  
  const password = page.getByLabelText(/password/i)
  fireEvent.change(password, { target: { value: "helloworld" } })
  
  fireEvent.click(submitButton)
  
  expect(() => page.getByText(/Loading/i)).not.toThrow()
  expect(submitButton.disabled).toBe(true)
  
  expect(User.createUser).toHaveBeenCalledWith({
    email: "john@gmail.com",
    password: "helloworld",
  })
  
  await tick()
  
  expect(navigateSpy).toHaveBeenCalledWith("/")
  
  expect(SocialLogin).toHaveBeenLastCalledWith(
    {
      loginEnpointRootUrl: API_BASE_URL,
    } as PropsType<typeof SocialLogin>,
    {},
)
  
  // ... more
}) 
```

```js showNumbers subtitle="After" 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=> {})
  test("Pending submission displays loader", ()=> {})
  test("Successful login redirects to dashboard", ()=> {})
}) 
```

</Step> 

<Step>

```diff 
```

```diff 3[300]
```

</Step>

<Step>

```diff 
```

```diff 
```

</Step>


</CodeSurferColumns>  

<Notes>

- Avant: 
- Test vas couter cher en maintenance et énergie
- Enorme surface à apprendre
- Si dois ajouter/fixer cas, prends aprem


- Apres:
- Set petits tests concentrés sur pb unique
- Peu de code à gérer
- "=" + agile, si regle change, facile
- Meilleur infos failure

</Notes> 

<!-- 👉 BA END 👈 -->

---

<HardToNavigateRefactors active={0} />

<Notes>

- Quand test qui fait tout
- Re-scoper/découper aidant convention nommage

</Notes>

---

<!--
****************************
****************************
** 👃 Mixed steps
****************************
****************************
-->

<Chapter emojis="🕺" title="Mixed steps" />

<Notes>

- On a suite petits tests dédiés à pb précis
- Next, pouvoir trouver marques

- Etapes mélangées

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js  showNumbers
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff 6,11 showNumbers
```

```diff 5,8,10 showNumbers
```

```diff 2:4,7,9
```

```diff 
```

```js showNumbers 2:6 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  type(password, "credentials.password")
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 7:9 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6 10:11 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff showNumbers 2:6 
```

```diff showNumbers 7:9 
```

```diff showNumbers 10:11 
```

```js showNumbers 1:14
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

</CodeSurfer>

<Notes>

- Vérifie redirigé vers page d'accueil quand on se log
- Quand test fail et msg failure insuffisant, veut cibler rapidement pb
- Aka idée attentes (assertions), comment fonctionne (actions font assertions passent), données nécéssaires test (setup)

- Ici mélangées [assertion] [actions] [setup]
- [Pb ?]
    - Pas standardisé, pas carte précise A then B then C
    - Potentiellement moins stricte/qualité (dépendances entre étapes)
- Comment mieux ?
- Identifié trois groupes (setup, actions, attentes) -> Rendre explicites
- [setup], [actions], [attentes]
- Déroulement clair et valide pour tous tests
- [A], [A], [A]
- [Ajouter espaces]
- Tout de suite, quelque soit sujet test, je sais déjà comment aborder/ou trouver quoi

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 FUNFACT START 👈 -->

<FunFact/>

---

<CodeSurfer>

```js showNumbers 12
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff showNumbers 2:6,8:10,13  
```

```diff showNumbers  3,6,12
```

</CodeSurfer>

<Notes>

- Suite réarrangement, cassé assertion


- Dit bouton submit désactivé quand formulaire pas remplis
- Faux puisque formulaire remplis dans etape act


- Assertion cassée après groupement étapes: Avez découvert second test
- 2 run AAA

</Notes>

<!-- 👉 FUNCFACT END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers subtitle='After'
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

</Step>

<Step>

```diff 
```

```diff 7
```

</Step>

<Step>

```diff 7[300]
```

```diff 
```

</Step>


</CodeSurferColumns>

<Notes>

- Avant: 
- Si failure, falloir chercher pièces
- Chaque test parrait nouveau


- Après
- Standardisé étapes de tous test
- Peux localiser rapidement assertions et remonter
- Accessoirement, spaces = fais mois peur
- Quelque soit sujet test, je connais déjà moitié fonctionnement

</Notes>

<!-- 👉 BA END 👈 -->

---

<HardToNavigateRefactors active={1} />


<Notes>

- Regroupe étape en AAA

</Notes>

---

<!--
****************************
****************************
** 👃 THE UNICORN
****************************
****************************
-->

<Chapter emojis="🦄" title="Unicorn" />


<Notes>

- Peut retrouver rapidement étapes test
- Mais si implémentation test complètement différente de tout vu ailleurs ds appli
- Vas pas suffir


- Licorne = quand test fait choses différement rest appli (sans bonnes raisons)

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

<Step>

```diff 2:4,9 
```

```diff 6[300]
```

</Step>

<Step>

```diff 6[300]
```

```diff 2:4,6,10 
```

</Step>

<Step>

```diff 4,7,9
```

```diff 4,8,10
```

</Step>

</CodeSurferColumns>

<Notes>

- 2 tests (service A et B) vérifient services ajoute truc à bdd


- Premier via vrai collabs
- Second via mocks


- Pourtant font exactement mm chose
- "Prend truc, ajout, verifie ajouté"
- Donc mm chôse, implémentation complètement différente
- PB ?
- Bah tout à coup dois apprendre à me servir des mocks -> pas mm temps nécéssaire
- Comment faire mieux ?

</Notes>   

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
    const db = { add: jest.fn() }
    const validator = { allows: jest.fn() }
    const user = "user"
    const repository = new ProductsRepository(db, validator)
    validator.mockResolvedValue(true)
    
    await repository.add(user)
    
    expect(db.add).toHaveBeenCalledWith("users", user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

</CodeSurferColumns>

<Notes>

- Choisit strategie
- On s'y colle
- Si décide tests services via mock
- Fait touts tests service via mock 

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<HardToNavigateRefactors active={2} />

<Notes>

- Face Licorne
- Standardize
- Regarde comment fait ailleurs, et fait pareil
- J'ai déjà savoir nécéssaire quand arrive sur test

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!-- 👉 SECTION RECAP 👈 -->

<HardToNavigateRefactors />

<Notes>

- Chaque test familié quelque soit team member qui a écris
- Mm si découvre test
- mm Découpage (méthode -> pre-condition -> comportement)
- mm Structure/visuel (A, A, A)
- mm Implémentation (Standardization méthode)
- Friction réduite

</Notes>

<!-- 👉 SECTION RECAP 👈 -->

---

<!--
*****************************************************************************
*****************************************************************************
** Unclear 💯 *********************************************************
*****************************************************************************
*****************************************************************************
-->

<Sections active={1}/>


<Notes>

- Next: arriver à comprendre ce qui se passe


- Aka
- Mettre en valeur ce qui importance dans test
- Cacher le reste
- Trouver bon niveau de détail pour compréhension rapide
- Pour si test ko
- Pas investiguer choses qui ont aucune importance

</Notes>

--- 

<!--
****************************
****************************
** 👃 Meaningless recipe
****************************
****************************
-->

<Chapter emojis="📚🤨" title="Meaningless recipe" />

<Notes>

- Recette qui n'a pas de sens

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 12:17 showNumbers
```

```diff 
```


```diff 7,12:14 showNumbers 
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    type(/email/i, credentials.email, page )
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 14,19
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    type(/email/i, credentials.email, page )
    type(/password/i, credentials.password, page )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 19,14
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

const submit = (target, page) => {
  const element = page.getByRole("button", { name: /login/i } )
  fireEvent.submit(element)
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    type(/email/i, credentials.email, page )
    type(/password/i, credentials.password, page )
    submit(/login/i, page)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 24
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

const submit = (target, page) => {
  const element = page.getByRole("button", { name: /login/i } )
  fireEvent.submit(element)
}
 
const waitForPendingPromisesToComplete = () => 
  new Promise(resolve => process.nextTick(resolve))

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    type(/email/i, credentials.email, page )
    type(/password/i, credentials.password, page )
    submit(/login/i, page)
    await waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 1:14
```

```js showNumbers 
// custom-render.js
export const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => { /* code */ }
  
    const submit = (target) => { /* code */ }

    const waitForPendingPromisesToComplete = () => { /* code */ }
  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}
```

```diff 3,11
```

```js showNumbers 6 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    type(/email/i, credentials.email, page )
    type(/password/i, credentials.password, page )
    submit(/login/i, page)
    await waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})

function renderLoginPage() {
  const page = customRender(<LoginPage />)
  
  return {...page} 
}
```

```diff 7 
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})

function renderLoginPage() {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => 
        when(login(credentials)).mockResolvedValue(true)
 
  return {...page, allowLoginFor}
}
```

```diff 9:10 
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})

function renderLoginPage() {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => 
        when(login(credentials)).mockResolvedValue(true)

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  return {...page, allowLoginFor, fillInLoginForm}
}
```

```diff 10:11
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})

function renderLoginPage() {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => 
        when(login(credentials)).mockResolvedValue(true)

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }
  
  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}
```

```diff 6:10
```

</CodeSurfer>

<Notes>

- Test vérifie redirigé vers page d'accueil quand login

- Si regarde recette test (actions à effectuer pour recréer cas de test)
- 5 lignes mais Impossible comprendre 
- Pb ? Plutot qu'arriver sur test, passer 2 sec sur liste étapes nécéssaires pour que passe et lancer investigations
- Dois passer temps à décoder ce qui se passe, comprendre étapes, fonctionnement test
- Sors complètement contexte, pas objectif


- Comment mieux ?
- Objectif: Trouver concepts/idées cachées sous instructions et faire apparaitre


- Quel concept derrière X ? Y -> cacher détail, faire apparaitre concept (extraire utilitaire et appliquer)


- Comme helpers utiles partout -> ajouter à framework (prend render, rééxporte avec helpers)


- Créé helpers pour concept page en général -> helper <LoginPage/> 
- renderLoginPage
- Fini avec suite instruction type guide utilisateur
- Si form login change (add captcha, un seul endroit à changer)
- (intercators/page object: objet/ensemble méthodes dédiés tests page/objet)

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<FunFact />

---

<CodeSurfer>

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})

function renderLoginPage() {
  const page = customRender(<LoginPage />)
  
  // ...stuff

  return {...page, allowLoginFor, fillInLoginForm, login}
}
```

```diff 15:32
```

</CodeSurfer>


<Notes>

- Mis utilitaires en dessous
- Parce que c'est un détail
- Quand ouvre fichier test, veut voir test
- Si besoin creuser, alors irais voir helpers

</Notes>

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers subtitle="After" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

<Step>

```diff 12:17
```

```diff 8
```

</Step>

<Step>

```diff 11
```

```diff 6:10
```

</Step>


</CodeSurferColumns>

<Notes>


- Avant
- Suite instructions sans aucun sens 
- Demande connaissance du framework (target.value)


- Après
- Recette simple pour recréer etat testé
- Se lit comme un guide utilisateur/spec
- Si test cassé, en 2 secondes comprends test et prêt à débugger 

</Notes>

<!-- 👉 BA END 👈 -->

--- 

<UnclearRefactors active={0}  />


<Notes>

- Quand suite instruction qui veulent rien dire
- Décrit le quoi (type), pas le comment (firevent type change avec value "blah")

</Notes>

---

<!--
****************************
****************************
** 👃 LOST IN DETAILS
****************************
****************************
-->

<Chapter emojis="🗺😤" title="Lost in details" />

<Notes>


- Clarifié/Donné sens à recette/étapes test
- Next: Mettre en valeur détails importants
- Aka, quoi dans mise en place fait test fail/pass

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 2:7
```

```diff 9
```

```diff 2:9
```


```diff
```

```js showNumbers 
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 1[19:27],7
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 12:13
```

```js showNumbers 
test("Valiation success adds user to repository", () => {
    const user =  makeUser.approvedByIdentity()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</CodeSurfer>

<Notes>

- Test vérifie utilisateur bien ajouté à bdd


- Commence par long setup user
- Validateur identité ? -> probablement un truc avec user
- Pb? Incapable de dire quelle prop fait test pass/fail
- Surface débug large -> creuser validateur ident
  

- Comment mieux ?


- Objectif: Veux voir seullement détails qui comptent
  

- Méthode: générer automatiquement toutes props qui comptent pas
- Overrides -> Spécifier seulement importantes 
- Vois seullement props importantant


- factory


- email + password = découverte concept
- Partager avec reste appli via factory preset

</Notes>

<!-- 👉 REFACTOR START 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</Step>


<Step>

```diff 2:8
```

```diff 5[100]
```

</Step>


<Step>

```diff 5[100]
```

```diff 2:5
```

</Step>

</CodeSurferColumns>


<Notes>

- Avant:
- Tout même niveau importance
- Impossible savoir ce qui fait test pass/fail

- Après:
- Immédiatement clair Combo email password important
- Si test fail, vais pas perdre temps sur (nom/prenom/...) alors qu'en fait comptent pas

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UnclearRefactors active={1} />

<!-- 👉 OUTLINE END 👈 -->

<Notes>

- Quand trop détails
- Met valeur ce qui compte
- (poi = point of interest)

</Notes>

---

<!--
****************************
****************************
** 👃 SUSPICIOUS VALUES
****************************
****************************
-->

<Chapter emojis="👮‍♂️📦" title="Suspicious values" />

<Notes>

- Mis en valeur détails comptent dans test


- Parfois ces pièces doivent avoir valeur spéciique pour test fonctionne (combo mail/ldap)
- Parfois on s'en moque (juste vérifier valeur passé à collab/présente) 


- Valeurs suspectes = valeurs qui paraissent importantes, mais en fait non

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
const count = 2
```

```js showNumbers
const date = "20/03/2018"
```

```js showNumbers 3:4 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "john@imedia.com",
       password: "57456",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "john@imedia.com",
       password: "57456",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```
</CodeSurfer>


<Notes>

- Why 2, why not 1
- And why not 0
- Whay "20/03/2018" why not 21st ?
  


- Qu'est-ce qui dans cet email fait que test passe ou echoue ?
- Ou défini combo valide ?
- PB ? 
- Mène à programmation par superstition
- Piste de débugging inutile si test fail (aka temps perdu)


- Commen mieux ?
- Objectif:  Rendre clair si test fail, pas besoin regarder là
  

- Dé-spécifier valeurs
- Utiliser placeholder
- Nommer objet auquel appartiennent

</Notes>

---

<TestReport name="Some service test">
    <Matchers.ToHaveBeenCalledWith  actual="credentials.password" expected="credentials.email" fnName="login" />
</TestReport>


<Notes>

- Vas aider en cas failure

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 FUNFACT START 👈 -->

<FunFact/>

<Notes>

- Attention à pas aller trop loin

</Notes>

---

<CodeSurfer>

```js showNumbers 3,4
test("<LoginPage/>", async () => {
    const credentials = {
       email: "waffles",
       password: "pancakes",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "🕺",
       password: "🙈",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</CodeSurfer>

<Notes>

- A un moment utilisais waffles/batman/...
- D'autres utilisent emojis
- Marrant jusqu'au moment ou failure
- Donne respectivement

</Notes>

---


<TestReport name="Some service test">
    <Matchers.ToHaveBeenCalledWith  actual="pancakes" expected="waffles" fnName="login" />
</TestReport>


---

<TestReport name="Some service test">
    <Matchers.ToHaveBeenCalledWith  actual="🕺" expected="🙈" fnName="login" />
</TestReport>

<Notes>

- Moment ou on réévalue serieusement choix vie

</Notes>

<!-- 👉 FUNFACT END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 2[100]
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

<Step>

```diff 2[100]
```

```diff 2:5
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant:
- Inverse précédent, mise en valeur détail sans importance
- Donc, confusion


- Après
- Gain temps
- Clair si test fail, pas besoin regarder là
- pb ailleurs
- Meilleure failure 

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UnclearRefactors active={2}/>

<Notes>

- Valuer supspecte -> Remplacer par placehoder

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!--
****************************
****************************
** 👃 Duplicate naming
****************************
****************************
-->

<Chapter emojis="👶👶" title="Duplicate naming" />

<Notes>

- Clarifié quelles props objets font test pass/fail
- Raté opportunité avec nommage objets  


- From duplicate comment

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
// Creates express router
const router = express.Router()
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const identityApprovedUser =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:7,14,16
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```diff 2:7
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: matchingUser.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</CodeSurfer>


<Notes>

- Duplicate comment = quand code dis ce qu'il vas faire et le fait. J'ai vu


- variable user avec resultat makeUser.
- Vrai, mais j'ai vu que c'etait user
- Comme montrer du doigt un chaise et dire chaise. Vrai mais pas très pertinent
- Comment mieux ?


- Plutot que dire ce que c'est, pourrais dire ce qui le rend spécial dans test
- Concept chaché = identityApprovedUser
- Nom var = opportunité dire plus, préciser concept, donner + indices


- Test vérifie get() repo avec critères retourne utilisateur matche critères  
- Quelle idée derrière "ldap_1" et "ldap_2"
- Mettre à jour concept

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```js showNumbers 
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: matchingUser.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</Step>

<Step>

```diff 2[11:16],5[11:16],16,14[40:57]
```

```diff 2[200],5[200],16[200]
```

</Step>



<Step>

```diff 2[200],5[200],16[200] 
```

```diff 2[11:23],5[11:25],16,14[40:200]
```

</Step>


</CodeSurferColumns>


<Notes>

- Avant: 
- Décris objet
- A nous parcourir test et trouver concept chache derrière valeur ldpap


- Après: 
- Pas besoin lire assignation variable
- Un user match, pas l'autre
- Si on décrivait fonctionnement à qqun, c'est probablement comme ça qu'on dirais
- "get retourne premier utilisateur qui match"

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UnclearRefactors active={3} />

<Notes>

- Quand nom var décrit juste objet contenu (user)
- Renommer objet en fonction role dans test (matching user)

</Notes>

<!-- 👉 OUTLINE END 👈 -->

--- 

<!-- 👉 SECTION RECAP 👈 -->

<UnclearRefactors />

<Notes>

- Vu comment clarifier recette/étapes test
- Mettre en valeur détail important et cacher reste
- Donner un sens aux différents éléments/objets qui composent test  

</Notes>

<!-- 👉 SECTION RECAP 👈 -->

---

<!--
*****************************************************************************
*****************************************************************************
** Feedback 👌 *********************************************************
*****************************************************************************
*****************************************************************************
-->

<Sections active={2}/>

<Notes>

- Next: feedback  
- When fail, in ci/during refactor
- Erreur doit être suffisante pour lancer investigations/comprendre cause pb
- On a tests lisibles 
- Encore mieux si pas besoin ouvrir test

</Notes>

---

<!--
****************************
****************************
** 👃 MEANINGLESS VALUES
****************************
****************************
-->

<Chapter emojis="🤹‍♂️😑" title="Meaningless values" />

<Notes>

- Valeurs qui ne veulent rien dire 

</Notes>



















---

<!-- 👉 REFACTOR START 👈 -->

<TestReport name="chars() returns every char in string">
    <Matchers.ToBe actual={5} expected={0} />
</TestReport>

<Notes>

- Test échoue avec erreur suivante
- C'est quoi 0, c'est quoi 5 ?
- Aucun contexte pour comprendre signification valeurs
- Vérifie char() retourne tableau contenant chaque char string
- PB ? Test fail pendant refactor, pas contexte nécéssaire pour corriger pb sans stopper et aller éplucher test
- changement de context 
- Aka double perte de temps: prise en main test + retourner à tâche en cours


- Comment mieux ?
- Idéalement, failure permet comprendre et cibler cause pb sans ouvrir test

</Notes>

---

<CodeSurfer>

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string).length).toBe(5)
})
```

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string)).toHaveLength(5)
})
```

</CodeSurfer>


<Notes>

- 0 et 5 = longueur du tableau retourné
- Comment donner sens à valeurs ?


- Pb vient matcher
- Générique toBe
- Matcher générique = message générique
- Framework fourni pleins matchers dédiés à pbs spécifiques
- Avec message spécifiques
- Ici Arrays
- Donc job = choisir celui qui à meilleur message pour pb

<br/>

- toHaveLength 
- dédié arrays
- message super spécifique

</Notes>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToHaveLength actual={0} expected={5} passed={[]} />
</TestReport>

<Notes>

- Clarifies 5 & 0 numbers are array length
- Event prints the array 
- Donné contexte/signification aux chiffres
- Comprends que code source retourne tableau temporaire au lieu du résultat (ou pas implémenté à ce niveau)

</Notes>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBe actual={false} expected={true} />
</TestReport>


<Notes>

- Check peut pas re-soumettre formulaire quand requete en cours
- Erreur: expected true but false
- check used matcher

</Notes>

---

<CodeSurfer>

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button.disabled).toBe(true)
})
```

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button).toBeDisabled()
})
```

</CodeSurfer>

<Notes>

- True bc check .disabled
- Matcher dédié

</Notes>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBeDisabled />
</TestReport>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<SplitBA
 left={
        <TestReport zoom={.7} name="chars() returns every char in string">
            <Matchers.ToBe actual={5} expected={0} />
        </TestReport>
 } 
 right={
        <TestReport zoom={.7} name="chars() returns every char in string">
            <Matchers.ToHaveLength actual={0} expected={5} passed={[]} />
        </TestReport>
 } 
/>

<Notes>

- Avant: Erreur cryptique
- Que signigient 0 & 5 ?
- Vas falloir aller chercher dans test pour comprendre


- Après:
- 0 et 5 = array length
- Donne sens aux chiffres
- Bonne failure donne/sens contexte à valeurs reçues

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UselessFailureRefactors active={0} />

<Notes>

- Valeurs qui n'ont aucun sens
- Donner contexte
- (fait via matcher mais pourrait juste etre message erreur custom)

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!--
****************************
****************************
** 👃 Giant diff
****************************
****************************
-->

<Chapter emojis="🤷‍♂️" title="Giant diff" />

<Notes>

- parfois manque d'infos
- parfois juste trop 


- Giant diff

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<TestReport name="Orders users by id descending">
    <Matchers.ToEqual 
        actual={[{
          "address":  {
              "city": "user.address.city",
              "city": "user.address.city",
              "street": "user.address.city",
          },
          "id": 3,
          "birthdate": "user.birthdate",
          "firstname": "user.firstname",
          "lastname": "user.lastname",
        }]} 
       expected={[{
            "address":  {
                "city": "user.address.city",
                "city": "user.address.city",
                "street": "user.address.city",
            },
            "id": 1,
            "birthdate": "user.birthdate",
            "firstname": "user.firstname",
            "lastname": "user.lastname",
        }]} />
</TestReport>


<Notes>

- Check users triés par id descendant

<br/>

- Dump deux tableaux, à nous trouver diff
- Noyés d'infos (inutiles)
- J'imagine pb tri. Mais lequel... (mauvais sens ? pas ordonné ?)
- PB ? Comme tous tests sections:
    - perte temps/flow changement contexte 
    - et si CI, prier reproduisible en local
    
- Comment mieux ?

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users)

  expect(result).toEqual([user3, user2, user1])
})
```

```diff 6
```

```js showNumbers 
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users).map(prop("id"))
  
  expect(result).toEqual([3, 2, 1])
})
```

```diff 4[35:51]
```

```diff 6[26:35]
```

</CodeSurfer>

<Notes>

- Actuellement,noyés infos 
  

- Pkoi ? Compare deux tableau d'objets complets (aka nom+prenom+date naissance, etc)

- Objectif: 
- Pb tri, identifier rapidement quel item est/sont pas dans bon ordre
  

- Réduire infos contenues dans deux tableau au strict nécéssaire
- Plutot faire un diff entre 2 tableaux users -> diff deux tableaux id 
- Sélection prop id 
- Match contre tableau id attendu
- Id = info simple pour comparer ordre attendu/recu

</Notes>

---

<TestReport name="Orders users by id descending">
    <Matchers.ToEqual actual={[1,2,3]} expected={[3,2,1]} />
 </TestReport>

<Notes>

- Failure montre pb tri: Tous items mais pas bon ordre
- Diagnostique clair, pas besoin passage test
- (note pour aider ids= 1,2,3 plutot que 12,14,18)

</Notes>

---

<TestReport name="Gets user by id">
    <Matchers.ToEqual 
        actual={{
          "address":  {
              "city": "user.address.city",
              "city": "user.address.city",
              "street": "user.address.city",
          },
          "id": 3,
          "birthdate": "user.birthdate",
          "firstname": "user.firstname",
          "lastname": "user.lastname",
        }} 
       expected={{
            "address":  {
                "city": "user.address.city",
                "city": "user.address.city",
                "street": "user.address.city",
            },
            "id": 1,
            "birthdate": "user.birthdate",
            "firstname": "user.firstname",
            "lastname": "user.lastname",
        }}
    />
 </TestReport>

<Notes>

- Checks récup bon user

<br/>

- Mm chôse dump props user
- A nous comparer objets
- Dur localiser pb

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result).toBe(user2)
})
```

```diff 6 
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result.firstname).toBe(user2.firstname)
})
```

</CodeSurfer>

<Notes>

- compare deux objets pleins again
- Pourrait faire pareil et map(id) mais pas beaucoup plus avancé
- Veut message erreur parle language test
- Aka dise "mauvais utilisateur retourné"
- Donc comment identifier rapidement user ? -> nom



- Sélect prop identifiant
- Transfo résult

</Notes>

---

<TestReport name="Gets user by id">
    <Matchers.ToEqual 
        actual="john"
       expected="bob"
    />
 </TestReport>

<Notes>

- Résultat clair, "retourne pas bon user"

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<SplitBA 
    left={
    <TestReport name="Orders users by id descending">
        <Matchers.ToEqual 
            actual={[{
              "address":  {
                  "city": "user.address.city",
                  "city": "user.address.city",
                  "street": "user.address.city",
              },
              "id": 3,
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
              "lastname": "user.lastname",
            }]} 
           expected={[{
                "address":  {
                    "city": "user.address.city",
                    "city": "user.address.city",
                    "street": "user.address.city",
                },
                "id": 1,
                "birthdate": "user.birthdate",
                "firstname": "user.firstname",
                "lastname": "user.lastname",
            }]} />
    </TestReport>
    } 
    right={
    <TestReport name="Orders users by id descending">
        <Matchers.ToEqual actual={[1,2,3]} expected={[3,2,1]} />
     </TestReport>
    } 
/>

<Notes>

- Avant: 
- A nous de faire le travail
- Aucun indice sur cause pb (mauvais ordre ? pas de tri ? Quel item pose pb ?)
- Pourrait mm être un item manquant


- Après:
- Pas besoin chercher
- Comparaison immédiate et claire entre reçu et attendu
- Mm sans lire nom pb évident -> attendais 3,2,1 reçu 1,2,3
 
</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UselessFailureRefactors active={1} /> 

<Notes>

- Quand diff géant
- Sélectionner valeur permet identifier pb

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!--
****************************
****************************
** 👃 NO ID 
****************************
****************************
-->

<Chapter emojis="😶" title="John doe" />

<Notes>

- Vu donner sens valeurs affichées dans erreur
- Parfois valeur compte pas
- Veut juste vérifier passé bon objet/appelé méthode avec bons params  
- John doe = arrive pas à identifier pkoi objets passés pas bons (squoi leur pb ?)

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<TestReport name="Displays turn winner">
    <Matchers.ToHaveBeenCalledWith 
        fnName="ui.notifyWinner()"
        actual={{"name": "player_name_2", "magic": 10, "strength":20, hp: 100 }}
        expected={{"name": "player_name", "magic": 20, "strength":100, hp: 200 }}
    />
</TestReport>
 
<Notes>

- test vérifie gagnant match affiché écran


- Pour vérifier ca: check ui.notifyWinner appelé avec bon paramètres
  
- Regarde failure: On attendais info spécifiques A et eu infos spécifiques B
- Mais pas clair: quoi reçu à la place? quoi'attendais? 

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Displays turn winner`, (  ) => {
	const winner = makeWinner()
    const looser = makeLooser()
    const ui = { notifyWinner: jest.fn() }
    const game = new Game(ui)
    
    game.turn(winner, looser)

    expect(ui.notifyWinner).toHaveBeenCalledWith(winner)
})
```

```diff 2:3
```

```diff 7
```

```diff 9
```

```diff 2:3
```

```diff 9
```

```js showNumbers
test(`Displays turn winner`, (  ) => {
	const winner = "turn_winner"
    const looser = "turn_looser"
    const ui = { notifyWinner: jest.fn() }
    const game = new Game(ui)
    
    game.turn(winner, looser)

    expect(ui.notifyWinner).toHaveBeenCalledWith(winner)
})
```

```js showNumbers
import traceable from "jest-traceable"

test(`Displays turn winner`, (  ) => {
	const winner = traceable(makeWinner(), "turn_winner")
    const looser = traceable(makeLooser(), "turn_looser")
    const ui = { notifyWinner: jest.fn() }
    const game = new Game(ui)
    
    game.turn(winner, looser)

    expect(ui.notifyWinner).toHaveBeenCalledWith(winner)
})
```

</CodeSurfer>

<Notes>

- Comment traduit niveau test ? 
  

- Créé joueurs
  

- Vérifie notifyWinner appelé avec gagnant
  

- Encore une fois utilise user complet, donc dump user complet dans failure test
  

- Mais ici pas retour, rien à transformer. Passage gagnant à notifyWinner à intérieur code source. 
- Comment peux identifier rapidement reçu et attendu


- Tagger objets
- Si valeurs pas utilisées (juste déléguées), juste remplacer par string
- Si besoin (prop utilisée à autre endroit code), peux tagger l'objet

</Notes>

---

<TestReport name="Displays turn winner">
    <Matchers.ToHaveBeenCalledWith 
        fnName="ui.notifyWinner()"
        actual={"turn_looser"}
        expected="turn_winner"
    />
</TestReport>

<Notes>

- Sais immédiatement pb: mauvais objet reçu
- Et fix: Passer gagnant

</Notes>

---

<FunFact/>

---

<CodeSurfer>

```js showNumbers
const traceable = (object, identifier) => {
  return Object.assign( object, { 
    toJSON: () => identifier 
  })
}
```

```diff 3
```

</CodeSurfer>

<Notes>

- Traceable fait rien spé
- Jest utilise toJSON pour afficher objet
- On l'override juste

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<SplitBA 
    left={
    <TestReport name="Displays turn winner" zoom={.7}>
        <Matchers.ToHaveBeenCalledWith 
            fnName="ui.notifyWinner()"
            actual={{"name": "player_name_2", "magic": 10, "strength":20, hp: 100 }}
                    expected={{"name": "player_name", "magic": 20, "strength":100, hp: 200 }}
        />
    </TestReport>
    } 
    right={
        <TestReport name="Displays turn winner" zoom={.7}>
            <Matchers.ToHaveBeenCalledWith 
                fnName="ui.notifyWinner()"
                actual={"turn_looser"}
                expected="turn_winner"
            />
        </TestReport>
    } 
/>

<Notes>

- Avant:
- A nous faire travail
- A nous deviner à quoi correspond objet 


- Après:
- Sais immédiatement pb: mauvais objet reçu
- Et fix: Passer gagnant

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<UselessFailureRefactors active={2}/>

<Notes>

- Tagger objets pour identification rapide

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!-- 👉 SECTION RECAP 👈 -->

<UselessFailureRefactors />

<Notes>

- Vu comment 
- donner context à erreurs (button not disabled > expected true but false)
- Faciliter identification pb (Attendais John, eu bob)
- Tagger objets pour faciliter debug (turn winner vs turn looser)
- Si test fail, reste en flow
- Pas besoin de stopper et ouvrir test pour comprendre et fixer pb

</Notes>

<!-- 👉 SECTION RECAP 👈 -->

---

<Sections active={3}/>

<Notes>

- Dernière étape assurer si Test casse c'est pour bonne raison:
- Quand comportement change
- Pas quand implémentation ou autre partie de l'app à changé
- Broken but working = test cassé alors que objet testé ok

</Notes>

---

<!--
****************************
****************************
** 👃 IMPLEMENTATION AWARE
****************************
****************************
-->

<Chapter emojis="🔎😏" title="Implementation aware" />

<Notes>

- Utilise connaissance implémention interne pour tester

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance.getData()

  expect(instance.loading).toBe(true)
})
```

```diff 3,5,7
```

```diff 
```


```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</CodeSurfer>

<Notes>

- Vérifie page affiche loader quand click refresh


- View, pourtant !test via ui
- Chercher controller -> déclencher refresh via methode -> vérif prop loading set true


- Pb? 
- Si implémentation change, test casse
- Si refactor et getData plus chargé assigner loading=true -> test casse
- Aka test peut être cassé, mais ui ok
- Inversement, test peut passer mais ui cassée (loading true garantis pas laoder affiché)


- Désolidariser implémentation interne
- Test via public api, here, view 
- Declancher refresh via event page et vérifier loader affiché
- Test casse seullement si vue casse

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance.getData()

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</Step>


<Step>

```diff 3[25:44],5[12:19],7[10:25]
```

```diff 4[200] 
```

</Step>



<Step>

```diff 5[200]
```

```diff 4[8:12],6[16:25]
```

</Step>

</CodeSurferColumns>


<Notes>

- Avant:
- Aucune garantie:
- Test peut être cassé et ui ok
- Ui peut être cassée et test ok


- Après: 
- Test via public api
- Protégé refactor
- ++ valeur: 
- Test casse seullemnt si cassé pour utilisateur 

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<BrokenButWorkingRefactors  active={0} />

<Notes>

- Quand test sait trop
- Tester via api publique

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<!--
****************************
****************************
** 👃 ENVIRONMENT DEPENDANT
****************************
****************************
-->

<Chapter emojis="🌳😘" title="Environment dependant" />

<Notes>

- Protégé refactors
- Mais pas seule chose externe qui peut casser test
- Autre smell: 
- Test qui dépend environnement

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```diff 5
```

```diff 2:5
```

```js
// fixtures/db/users.json
[
  {
    name: "John"
    // ...other props
  },
  // ...other users 
]
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "john"})
  const secondUser = makeUser({name: "bob"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe("john")
})
```

```diff 2:3
```

```diff 7:8
```

```diff 11
```

```diff 2[30:43],11[28:33]
```

</CodeSurfer>


<Notes>

- Vérifie first() récupère premier item dans table


- The fuck did john come from ?!
- Aucune mention dans tout le setup
- [John vient fixture]
- Test dépend environnement et fixtures vont avec 
  

- PB?
- aucun controle sur env
- si qqun autre bout appli pour faire passer test change nom utilisateur 1, test casse
- absurde, puisque marche
- donc perdre temps à débugger pb qui existe pas (dans code)
- trop fausses alertes = ignore vraies
- Comment mieux ?


- Créer environnement voulu
- Créé user et ajouter
- (Assume DB starts empty + reset)
- Capable faire lien nom -> donnée reçue
- Toutes données nécéssaires pour agir dans test
- controle données

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers 
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "john"})
  const secondUser = makeUser({name: "bob"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe("john")
})
```

</Step>

<Step>

```diff 
```

```diff 6
```

</Step>


<Step>

```diff 5
```

```diff 6 
```

</Step>


<Step>

```diff 4
```

```diff
```

</Step>

<Step>

```diff 4
```

```diff 2[30:43],11[28:33]
```

</Step>


</CodeSurferColumns>

<Notes>

- Avant:
- plus court
- test cassé veut pas dire fonction cassée
- Impossibe tracer ou john
- Enorme surface debug: 
- trouver setup fixtures, chercher fixutres users, vérifier bien ajoutées à db, ...
- (et modifier fixtures pour refaire passer test = casser autres tests)  


- Après:
- Plus long
- Pas risque intervention divine, controle mes données
- Test fail pour bonnes raisons 
- test cassé = code cassé
- Peut tracer d'ou vient valeur attendue

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<BrokenButWorkingRefactors active={1} />


<Notes>

- Quand test dépend environnement
- Créé propre environnement
- Controler données/environnement

</Notes>

<!-- 👉 OUTLINE END 👈 -->

---

<Chapter emojis="🤝" title="Interlinked" />

<Notes>

- Autre exemple test casse pour raisons non liées
- Interconnecté
- test casse autre partie feature change

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: `"Sku" is required`,
    price: `"Price" is required`,
  })
})
```

```diff 9:12
```

```diff 3,4,10[11:27],11[13:31]
```


```diff 
```

```js showNumbers
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: expect.any(String),
    price: expect.any(String),
  })
})
```

</CodeSurfer>

<Notes>

- Checks validateOrder liste toutes erreur validation pour commande donnée


- Objectif test: vérifier pour chaque clé en erreur (price) -> msg validation associé (price required)
- Ici: implicitement spécifie message retourné pour prop manquante ("blah is required")
- Mais but pas vérifier msg affiché, juste message retourné
- Msg validation à afficher quand prop manquante = autre partie spec donc autre test
- Donc test devrait pas casser si spec msg validation change ("price cannot be empty")


- PB ? agaçant de fixer un test quand tout marche, faux positif, perte confiance
  

- Objectif: Débarasser dépendance msg erreur
- Veut forme (string) pas détail "blah is required"
- Donc utiliser matcher permet vérifier forme
- Message validation peut changer sans casser test
- Tant que string, test passe

</Notes>

<!-- 👉 REFACTOR END 👈 -->

--- 

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: `"Sku" is required`,
    price: `"Price" is required`,
  })
})
```

```js showNumbers subtitle="After"
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: expect.any(String),
    price: expect.any(String),
  })
})
```

</Step>

<Step>

```diff showNumbers subtitle="Before"  3,4,10[11:27],11[13:31]
```

```diff showNumbers subtitle="After" 6
```

</Step>

<Step>

```diff showNumbers subtitle="Before" 10[200]
```

```diff showNumbers subtitle="After" 10[10:27],11[12:29]
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant:
- Dépendance implicite sur msg erreur/autre partie spec
- Si PO décide changer message validation, test casse 
- (absurde, pourquoi doit fixer un test qui vérfie autre chose quand update mesg validation)


- Apres:
- assertion plus souple
- Vérifie pas le détail (msg), simplement forme (string)
- Spec autour peut changer, test cassera pas
- Aussi objectContaining, arrayContaing, toMatchObject, ...

</Notes>

<!-- 👉 BA END 👈 -->

---

<!-- 👉 OUTLINE START 👈 -->

<BrokenButWorkingRefactors active={2} />

<Notes>

- Quand test lié autres parties spec
- relâcher/généraliser assertion
- Oublier détail, concentrer sur concepte général

</Notes>

---

<!--
****************************
****************************
** 👃 REDUNDANT COVERAGE
****************************
****************************
-->

<Chapter emojis="🙈🙈" title="Redundant coverage" />

<Notes>

- Celui qu'on voit plus
- Couverture de code redondante

</Notes>

---

<!-- 👉 REFACTOR START 👈 -->

<CodeSurfer>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1928 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```diff 3
```

```diff 3:4
```

```diff 
```

```diff 5
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = makeUser({ ldap: 1928 })
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```diff 6
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</CodeSurfer>

<Notes>

- Checks user validé par fournisseur identité ajouté db


- Vrais collabs -> validateur ident
- Imagine ldap spécifique nécéssaire pour passer validation
  

- PB? Casse si règle validation changent
- Si ldap plus valide
- Donc test vérifie implicitement fonctionnement validateur ident


- Objectif: Seule logique quoi doit impacter test = repo
- logique collabs nous embête -> remplacer par faux
- Au passage gain controle: Pour test besoin validateur accepte user 
- Maintenant nous qui décidons
- Débarasser chaque dépendance (validateur, user, db)
- Controle collab, tout peut changer autour, seul logique qui peut impacter test est dans le repo

</Notes>

<!-- 👉 REFACTOR END 👈 -->

---

<!-- 👉 BA START 👈 -->

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1928 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</Step>

<Step>

```diff 2,3,4
```

```diff 3[200]
```

</Step>

<Step>

```diff 3[200]
```

```diff 2,3,4
```

</Step>

<Step>

```diff 3[200]
```

```diff 6
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant: 
- Re-teste implicitement bon fonctionnement validateur/collaborateurs
- Si changent, test casse

<br/>

- Après:
- Controle collaborateurs
- Règle validation utilisateur peuvent changer test continuera passer
- Gagné en controle (when(validator)>true) -> plus besoin avoir en tête règles validateur ident
- Donc limité debug area
- Plus compliqué à mairiser

</Notes>

<!-- 👉 BA END 👈 -->

---

<BrokenButWorkingRefactors active={3} />

<Notes>

- Quand test dépend règles collabs
- Utilise faux collabs

</Notes>

---

<Sections active={0}/>

<Notes>

- Rendu onboarding sur test plus rapide

</Notes>

---

<Sections active={1}/>

<Notes>

- Facilité compréhension de tests

</Notes>

---

<Sections active={2}/>

<Notes>

- Transformé msgs erreur pour qu'ils contiennent max indices possibles sur cause failure

</Notes>

---

<Sections active={3}/>

<Notes>

- Supprimé dépendances tests.
- Plus de faux signals, mtn tests cassent quand code cassé

</Notes>

---

<FunFact />

<Notes>

- Pas oblige tout appliquer
- Si test à 1/2 smell mais tout à fait ok, pas forcément nécéssaire
- Si test épais  > diagnostiquer smell principal -> appliquer refactor
- Chaque refactor apporte mm bénéfices:
- Mieux communiquer déroulement
- Réduire surface débug
- Pour avancer plus vite

</Notes>

---

<Section title="Merci" emoji="🖖"/>

---

<Section title="Questions ?" emoji="🤓"/>

---


<!--

desc
pb
how better ?
name refactor
B/A commentarytradeofs evaluation
-->
