import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {Image, Appear} from 'mdx-deck'
import { github, vsDark, shadesOfPurple, base } from "@code-surfer/themes";
import ciFailBadNamingSrc from "./static/test_with_bad_naming_run_fail.png"
import image from "./src/components/image"
import TestReport, { Matchers } from "./src/components/test-report"
import Section  from "./src/components/section"
import Banner  from "./src/components/banner"
import Chapter  from "./src/components/chapter"
import SplitBA  from "./src/components/split"
import {Inline, Caption, Figure, EmojiSlide, TestsVsDevKnowledgeTable } from "./src/components"
import "./src/styles.css"
import SlidesTheme from "./src/theme.js"
import "typeface-gothic-a1"

export const theme = SlidesTheme

export const splitCodeSampleProps = {themes: [vsDark , theme]}


# 👋🌏

---

<EmojiSlide caption="Clean code">
🛀📝
</EmojiSlide>  

<Notes>

- Tous les jours importance clean code

</Notes>

---

<EmojiSlide caption="Our code">  
<ul>
    <li>🤱</li>
    <Appear>
        <li key="1">🤏</li>
        <li key="2">👶</li>
        <li key="3">🌹</li>
    </Appear>
</ul>
</EmojiSlide>


<Notes>

- Prendre soin code
- Méthodes courtes
- Renommer encore methodes, class, variable 
- Jusqu''à ce que ça se lise comme poésie
- Et puis pourtants fichiers test:

</Notes>

---

<CodeSurfer>

```ts showNumbers
test("<Signup/>", async () => {
    const navigateSpy = jest.fn()
    ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
        () => navigateSpy,
    )
    ;((User.createUser as any) as jest.MockInstance<
        ReturnType<typeof User.createUser>,
        any
    >).mockResolvedValue(null as any)
    ;((SocialLogin as any) as jest.MockInstance<
        ReturnType<typeof SocialLogin>,
        any
    >).mockImplementation(() => null)
    
    const page = render(<Signin />)
    
    const submitButton = page.getByRole("button", {
        name: /signin/i,
    }) as HTMLButtonElement
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Login & password required/i)).not.toThrow()
    
    const email = page.getByLabelText(/email/i)
    fireEvent.change(email, { target: { value: "john@gmail.com" } })
    
    const password = page.getByLabelText(/password/i)
    fireEvent.change(password, { target: { value: "helloworld" } })
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Loading/i)).not.toThrow()
    expect(submitButton.disabled).toBe(true)
    
    expect(User.createUser).toHaveBeenCalledWith({
        email: "john@gmail.com",
        password: "helloworld",
    })
    
    await tick()
    
    expect(navigateSpy).toHaveBeenCalledWith("/")
    
    expect(SocialLogin).toHaveBeenLastCalledWith(
        {
            loginEnpointRootUrl: API_BASE_URL,
        } as PropsType<typeof SocialLogin>,
        {},
    )

    // ... more
})
```

</CodeSurfer>

---

<EmojiSlide caption="I quit">  
    🏃‍♂️
</EmojiSlide>

<Notes>

- Moment ou souvient 18h, piscine, time to go home

</Notes>


---

# Refactoring tests

<Appear>
    <p>But why though ?</p>
</Appear>  

<Notes>

- Why
- J'ai des tests c'et pas suffisant ?

</Notes>

---



<EmojiSlide caption="Tests are a runnable specification">
🏃‍♂️📚
</EmojiSlide>  

<Notes>

- tests = spec executable
- Source de vérité:
- Comment chaque ecran app doit se comporter
- comment chaque edge case doit être géré

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩" tests="📚" result="😀" />

<Notes>

- Lors ajout feature/refactor 
- Permet concentrer / feature only
- Test watches for you
- = Avance + vite
- = + features
- = - bugs

<br/>

- Problème arrive quand deadline
- Par défaut Test = premier truc à sauter
- Donc refactor bc Si dur à aborder, tchao direct

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩📕" tests="📗📘" result="😐" />

<Notes>

- test en moins = pièce en plus
- cas erreur feature + cas erreur test supprimé

</Notes>

---


<TestsVsDevKnowledgeTable dev="🧩📕📗" tests="📘" result="😓" />

<Notes>

- Et à chaque test en moins doit garder + en + en mémoire 
- tendence inversée + en tête que ds tests
- 2 pas arrières pour 1 en avant

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩📚" tests="" result="🤯" />

<Notes>

- Jusque moment ou tendance complètement inversée
- A chaque changement doit tout vérifier 
- impossible toute app en tête 

</Notes>

---

<EmojiSlide>
    <span>
        📈
    </span>
    <Appear>
        <span>
        😤 
        </span>
        <span>💸</span>
    </Appear>
</EmojiSlide>

<Notes>

- Can't keep all that in mind
- So bugs
- frutrated users
- lost money

</Notes>

---

<EmojiSlide>
    <span>
    👃
    </span>
    <Appear>
     <span>→ 👷‍♂️</span>
    </Appear>
</EmojiSlide>
  
<Notes>

- but aujourd'hui: 
- Identifier smells qui font test difficile maintenir
- Voir pistes pour faire mieux
- combo smell -> refactor

</Notes>

---

// logo JS

<Notes>

- Aptable à n'importe quel language
- Probleme -> piste possible pour le résoudre
- Donc important = principe
- La façon dont fait et juste une piste possible

</Notes>

   
<!-- 
🏗 + 💯 + 👌 + 🤸‍
- Structure 🏗
- Expressiveness 💯
- Feedback 👌
- Flexibility 🤸‍
-->

---

<Section title="Structure" emoji="🏗" />

<Notes>

- Structure

- Veut contribution facile sous pression

- Impossible si chaque test réinvente la roue (naming, organisation, strategie)

- Voyage héros (matrix, hp, roi lion, sda, ...)

- Dans categorie, objectif:

- Tous tests similaires. Mm nommage, organisation, stratégie

- Histoire change, mais mm structure 

</Notes>

--- 

<!--
****************************
****************************
** 👃 UFOCUSED TESTS
****************************
****************************
-->

<Chapter emojis="🕺✅" title="Unfocused tests" />

<Notes>

- Test qui part dans tous les sens

</Notes>

---

<CodeSurfer>

```js  showNumbers
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff 6,11 showNumbers
```

```diff 5,8,10 showNumbers
```

```diff 2:4,7,9
```

```diff 
```

```js showNumbers 2:6 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  type(password, "credentials.password")
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 7:9 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6 10:11 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff showNumbers 2:6 subtitle="Arrange"
```

```diff showNumbers 7:9 subtitle="Act"
```

```diff showNumbers 10:11 subtitle="Assert"
```

```diff showNumbers 2:6 subtitle="Given"
```

```diff showNumbers 7:9 subtitle="When"
```

```diff showNumbers 10:11 subtitle="Then"
```

```js showNumbers 1:14
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```


```diff 12  
```

```diff showNumbers 2:6,8:10,13  
```

```diff showNumbers  3,6,12
```

</CodeSurfer>

<Notes>

- Vérifie redirigé vers page d'accueil quand on se log

<br/>

- Qu'est-ce qui fait test compliqué ?
- Fouilli 
- Quand test fail, et besoin + infos
- check assertions -> actions -> arrange
- Ici, sont cachées, Mélange: [setup][actions][vérification]
- En gros, dur à suivre

<br/>

- Comment rendre plus clair ?
- Grouper par type  
- + add spaces
- SIGNAL: 2 AAA

</Notes>

---

Arrange, Act, Assert 

<Notes>

- AAA

</Notes>

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers subtitle='After'
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Si failure
- Peux localiser rapidement assertions et remonter
- Pas besoin de chercher
- Accessoirement, spaces = fais mois peur 

</Notes>

---

<!--
****************************
****************************
** 👃 JUNK DRAWER
****************************
****************************
-->

<Chapter emojis="🗑🗄" title="Junk Drawer" />

<Notes>

- Fourre tout

</Notes>

---

<CodeSurfer>

```js showNumbers
test("<LoginPage/>", () => {
  // ...
}) 
```

```js showNumbers
test("<LoginPage/>", () => {
  // verify can't submit if empty form

  // verify email validation
  
  // Verify password validation
    
  // verify loading state
    
  // verify login fail displays error
    
  // verify login fail redirect error

  // more stuff
}) 
```

```js 1[6:39]
test("method -> condition -> behavior", ()=>{})
```

```js 1[6:18]
test("<LoginPage/> -> condition -> behavior", ()=>{})
```

```js 1[23:35]
test("<LoginPage/> -> failed login -> behavior", ()=>{})
```

```js 1[39:60]
test("<LoginPage/> -> failed login -> displays server error", ()=>{})
```

```js 1[7:54]
test("<LoginPage/> failed login displays server error", ()=>{})
```


```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {}) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {
    test("Displays server error", ()=>{})
    test("Requires captcha on subsequent attempts", ()=>{})
    //...
  }) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

</CodeSurfer>

<Notes>

- Juste 1 test ?
- Suspect
- Comment faire mieux ?
- Scoper via convention nommage
- nesting par condition

</Notes>


---

# Use naming to scope

---

<CodeSurferColumns  {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="before"
test("<LoginPage/>", () => {
    // verify can't submit if empty form
    
    // verify email validation
    
    // Verify password validation
    
    // verify loading state
    
    // verify login fail displays error
    
    // verify login fail redirect error
    
    // more stuff
}) 
```

```js subtitle="After" 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=> {})
  test("Pending submission displays loader", ()=> {})
  test("Successful login redirects to dashboard", ()=> {})
}) 
```

</Step> 

</CodeSurferColumns>  

<Notes>

- Part d'un test dump
- Set tests concentrés sur pb unique
- We probably surfaced more edge cases

</Notes> 

---

"I don't care"

<Notes>

- Au delà difficulté à aborder test
- Side effect = useless ci

</Notes>

---

<TestReport name="<LoginPage/>" >
    <span style={{color:"lightgray"}}>// Some random error</span>
</TestReport>

<Notes>

- Guess what the error is when you broke:
- Validation ?
- Redirection ?
- Error message ? 
- Yup

</Notes>

---

<TestReport name="<LoginPage/> Successful login redirects to dashboard" >
    <span style={{color:"lightgray"}}>// Some error that makes more sense now</span>
</TestReport>

<Notes>

- Can start investigating right away

</Notes>

---

<!--
****************************
****************************
** 👃 Unicorns everywhere
****************************
****************************
-->

<Chapter emojis="🦄🗺" title="Unicorns everywhere" />


<Notes>

- Chaque test = licorne/réinvente la roue

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

<Step>

```diff 2:4,9 subtitle="Real collaborators"
```

```diff
```

</Step>

<Step>

```diff 
```

```diff 2:4,6,10 subtitle="Mocks only"
```

</Step>

<Step>

```diff 4,7,9
```

```diff 4,8,10
```

</Step>

<Step>

```diff 
```

```diff 
```

</Step>

</CodeSurferColumns>

<Notes>

- 2 tests font exactement mm chose
- Prend truc, ajout, verifie ajouté
- Dur Contribuer
- Suite 10 tests chacun complètement différent
- Comment faire mieux ?

</Notes>   

---


Stick to your guns

<Notes>

- Choisit stratégie et on s'y colle 

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
    const db = { add: jest.fn() }
    const validator = { allows: jest.fn() }
    const user = "user"
    const repository = new ProductsRepository(db, validator)
    validator.mockResolvedValue(true)
    
    await repository.add(user)
    
    expect(db.add).toHaveBeenCalledWith("users", user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

</CodeSurferColumns>

<Notes>

- Ici test services via mock 

</Notes>

---

<!--
*****************************************************************************
*****************************************************************************
** Expressiveness 💯 *********************************************************
*****************************************************************************
*****************************************************************************
-->

<Section title="Expressiveness" emoji="💯" />


<Notes>

- Manque expressivité 

<br/>

- Veut test maintenable
- Travaillé structure -> capable trouver marque rapidement/nouveau test
- Next: arriver à comprendre ce qui se passe
- Aka
- Mettre en valeur ce qui importance dans test
- Cacher le reste
- Trouver bon niveau de détail pour compréhension rapide

</Notes>

--- 

<!--
****************************
****************************
** 👃 LOST IN DETAILS
****************************
****************************
-->

<Chapter emojis="📚🤔" title="Lost in details" />

---

<CodeSurfer>

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 12:17 showNumbers
```

```diff 12[5:20] showNumbers
```

```diff 13 showNumbers
```

```diff 7[29:52] showNumbers
```


```diff 7,12:14 showNumbers 
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 25
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 31
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 30:33
```

```diff 28 
```

```diff 30:31 
```

```diff 32:33
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue(true)

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue(true)
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue(true)

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 46
```

```diff 48
```
```diff 49
```

</CodeSurfer>

<Notes>

- 5 sec to tell me what this is doing
- Compliqué alors que peu de lignes
- How can we make that better ?

<br/>

- Framework gives low level pieces
- needs to work for anybody, any use case
- Pièces bas niveau cachent concept global
- Compose low level pieces into helpers
- Create page/item specific helpers to match domain
- (intercators) Global "page" helpers -> "LoginPage" helpers 

</Notes>

---

What, not how

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 7:17 subtitle="Before" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6:10 subtitle="After" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- 10 -> 5 lignes
- Parle termes domaine "LoginPage"
- Se lit comme spec "remplis login form", "log toi" 
- Compréhensible en 5s
- Centralized knowledge (bonus)

</Notes>

--- 

<!--
****************************
****************************
** 👃 SUSPICIOUS VALUES
****************************
****************************
-->

<Chapter emojis="👮‍♂️📦" title="Suspicious values" />

<Notes>

- Valeurs suspectes

</Notes>

---

<CodeSurfer>

```js showNumbers
const count = 2
```

```js showNumbers
const date = "20/03/2018"
```

```js showNumbers 3:4 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "🕺",
       password: "🙈",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```
</CodeSurfer>


<Notes>

- Why 2, why not 1
- And why not 0
- Whay "20/03/2018" why not 21st ?
- Does it really have to be a valid email ?
- Leads to programming par superstition

<br/>
  
- If data shape doesn't matter, show it (credentials.email)
- If value doesn't matter at all, show it (WHATEVER) 
- Si test fail, clair pb ailleurs
- Attention pas aller trop loin

</Notes>

---

<TestReport name="Some service test">
    <Matchers.ToHaveBeenCalledWith  actual="🕺" expected="🙈" fnName="login" />
</TestReport>

---

<TestReport name="Some service test">
    <Matchers.ToHaveBeenCalledWith  actual="credentials.password" expected="credentials.email" fnName="login" />
</TestReport>

---

Make the unimportant obviously unimportant

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 2[100]
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

<Step>

```diff 2[100]
```

```diff 2:5
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant: "dois passer email valide", "possiblement combo email/pwd"
- Programmation par superstition
- After: Reduced debug area
- Value shape doesn't matter for this test
- Even failure tells you shape doens't matter

</Notes>

---

<!--
****************************
****************************
** 👃 EVERYTHING BOLD
****************************
****************************
-->

<Chapter emojis="🌏👨‍🦲" title="Everything bold" />

---

<CodeSurfer>

```js showNumbers
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 2:7
```

```diff 9
```

```diff
```

```js showNumbers 
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 1[19:27],7
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 12:13
```

```js showNumbers 
test("Valiation success adds user to repository", () => {
    const user =  makeUser.approvedByIdentity()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</CodeSurfer>

<Notes>

- Test vérifie utilisateur bien ajouté à bdd

<br/>

- What in this user makes this test pass/fail
- I see a validator, so there's probably something going on
- I should be able to tell what
- How can we make that more obvious

</Notes>

---

Highlight what matters

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:8
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 5[100]
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</Step>


<Step>

```diff 5[100]
```

```diff 2:5
```

</Step>

</CodeSurferColumns>


<Notes>

- Avant: Impossible savoir ce qui fait test pass/fail
- Après: Only Combo email password matters

</Notes>

---

<!--
****************************
****************************
** 👃 Duplicate naming
****************************
****************************
-->

<Chapter emojis="👶👶" title="Duplicate naming" />

<Notes>

From duplicate comment

</Notes>

---

<CodeSurfer>

```js showNumbers
// Calls do something
doSomething()
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const identityApprovedUser =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:7,14,16
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```diff 2:7
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: matchingUser.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</CodeSurfer>


<Notes>

- Duplicate comment = dis ce que tu vas faire et le fait. J'ai vu

<br/>


- Terme domaine: identityApprovedUser

<br/>

- Test vérifie retourne utilisateur matche critères  
- Que veut dire "ldap_user1" et "ldap_user_2"

</Notes>

---

Put naming to work

<Notes>

- utiliser nommage pour mettre en valeur spécificités

</Notes>

--- 

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2[11:16],5[11:16],16,14[40:57]
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```js showNumbers 2[200],5[200],16[200]
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: matchingUser.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</Step>


<Step>

```diff 2[200],5[200],16[200] 
```

```diff 2[11:23],5[11:25],16,14[40:200]
```

</Step>


</CodeSurferColumns>


<Notes>

- Avant: Obligé lire test pour comprendre à quoi chaque user sert
- Dois remonter ldap, comparer ldap,...
- Après: Clair dès début, l'un mathc, pas l'autre. Pas besoin lire
- Proche spec

</Notes>

---

<!--
****************************
****************************
** 👃 MYSTERY GUEST
****************************
****************************
-->

<Chapter emojis="👻🎁" title="Mystery guest" />

<Notes>

- L'invité mystère

</Notes>

---


<CodeSurfer>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```diff 5
```

```diff 2:5
```

```js
// fixtures/db/users.json
[
  {
    name: "John"
    // ...other props
  },
  // ...other users 
]
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

```diff 2:3
```

```diff 7:8
```

```diff 11[10:21,28:41]
```

</CodeSurfer>


<Notes>

- Check récupère premier item dans table

<br/>

- The fuck did john come from ?!
- Si fail, dur de remonter jusqu'au pb
- Potentiellement failure non liée au code: changement fixtures
- Cas ou mutation fixtures dans appli legacy -> 3 jours debug

<br/>

- Assume DB starts empty + reset
- On sait ou vient nom
- controle donnée

</Notes>

---

Control your data


<Notes>

- Controler données/environnement

</Notes>

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers 6
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

</Step>

<Step>

```diff 5
```

```diff 
```

</Step>


<Step>

```diff 4
```

```diff 
```

</Step>

<Step>

```diff 4
```

```diff 2,11[28:42]
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant: plus court mais impossible de tracer failure
- Après:- Plus long
- Pas risque intervention divine
- Controle mes données
- Peut tracer d'ou vient valeur attendue
- Si failure, liée au code

</Notes>

---

<Section title="Feedback" emoji="👌" />

<Notes>

- Capables retrouver marques rapidement  
- Comprendre étapes et détails font test pass/fail rapidement

<br/>

- Next: feedback  
- When fail, in ci/during refactor (rester en flow)
- Erreur doit être suffisante pour lancer investigations/comprendre cause pb
- On a tests lisibles 
- Encore mieux si pas besoin ouvrir test


</Notes>

---

<!--
****************************
****************************
** 👃 Undefined is not a function
****************************
****************************
-->

<Chapter emojis="🎰🤡" title="Undefined is not a function" />

<Notes>

- Ever had that error
- Not quite useful right 
- True, but I still have no clue what the problem is

</Notes>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToBe actual={5} expected={0} />
</TestReport>

<Notes>

- Vérifie char() retourne tableau contenant chaque char string
- Pourtant message erreur parle de nombres 
- C'est quoi 0, c'est quoi 5 ?

</Notes>

---

<CodeSurfer>

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string).length).toBe(5)
})
```

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string)).toHaveLength(5)
})
```

</CodeSurfer>


<Notes>

- Pb vient assertion
- Générique toBe
- Matcher générique = message générique
- Framework fourni pleins matchers dédiés à pbs spécifiques
- Avec message spécifiques
- Ici Arrays
- Donc job = choisir celui qui à meilleur message pour pb

<br/>

- toHaveLength 
- dédié arrays
- message super spécifique

</Notes>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToHaveLength actual={0} expected={5} passed={[]} />
</TestReport>

<Notes>

- Clarifys 5 & 0 numbers are array length
- Event prints the array 


</Notes>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBe actual={false} expected={true} />
</TestReport>


<Notes>

- Check peut pas re-soumettre formulaire quand requete en cours
- Erreur: expected true but false
- check used matcher

</Notes>

---

<CodeSurfer>

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button.disabled).toBe(true)
})
```

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button).toBeDisabled()
})
```

</CodeSurfer>

<Notes>

- True bc check .disabled
- Matcher dédié

</Notes>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBeDisabled />
</TestReport>

---

Choose the right matcher for your test // switch matchers

---

<SplitBA
 left={
        <TestReport zoom={.7} name="chars() returns every char in string">
            <Matchers.ToBe actual={5} expected={0} />
        </TestReport>
 } 
 right={
        <TestReport zoom={.7} name="chars() returns every char in string">
            <Matchers.ToHaveLength actual={0} expected={5} passed={[]} />
        </TestReport>
 } 
/>

<Notes>

- Avant: Erreur cryptique
- Que signigient 0 & 5 ?
- Confusionnant -> peut me faire aller chercher pb au mauais endroit

<br/>

- Après:
- 0 et 5 = array length
- diff entre failure correcte et bonne failure:  
- Bonne failure donne contexte

</Notes>

---

<!--
****************************
****************************
** 👃 Memory dump
****************************
****************************
-->

<Chapter emojis="🧠🗑" title="Memory dump" />

<Notes>

Memory dump 

</Notes>

---

<TestReport name="Orders users by id descending">
    <Matchers.ToEqual 
        actual={[{
          "address":  {
              "city": "user.address.city",
              "city": "user.address.city",
              "street": "user.address.city",
          },
          "id": 3,
          "birthdate": "user.birthdate",
          "firstname": "user.firstname",
          "lastname": "user.lastname",
        }]} 
       expected={[{
            "address":  {
                "city": "user.address.city",
                "city": "user.address.city",
                "street": "user.address.city",
            },
            "id": 1,
            "birthdate": "user.birthdate",
            "firstname": "user.firstname",
            "lastname": "user.lastname",
        }]} />
</TestReport>


<Notes>

- Check users triés par id descendant

<br/>

- Memory dump = Dump complet deux tableaux
- A nous comparer tableau attendu vs reçu
- Noyé d'infos inutiles
- Styles aident pas mais erreur bien affichée. Juste chiant à trouver
- J'imagine pb ordering. Mais lequel... (mauvais sens ? pas ordonné ?)

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users)

  expect(result).toEqual([user3, user2, user1])
})
```

```diff 6
```

```js showNumbers 
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users).map(prop("id"))
  
  expect(result).toEqual([3, 2, 1])
})
```

```diff 4[35:51]
```

```diff 6[26:35]
```

</CodeSurfer>

<Notes>

- On prends tableau objet
- Vérifie matche autre tableau objets
- Donc dump
- Comment mieux ?

<br/>

- Simplifier résultat
- Choisit moyen plus simple pour identifier item et vérifier trie
- Order by id donc id
- Match contre tableau id dans ordre attendu

</Notes>

---

<TestReport name="Orders users by id descending">
    <Matchers.ToEqual actual={[1,2,3]} expected={[3,2,1]} />
 </TestReport>

<Notes>

- Le côté tri apparait dans test
- Failure montre pb tri
- (note pour aider ids= 1,2,3 plutot que 12,14,18)

</Notes>

---

<TestReport name="Gets user by id">
    <Matchers.ToEqual 
        actual={{
          "address":  {
              "city": "user.address.city",
              "city": "user.address.city",
              "street": "user.address.city",
          },
          "id": 3,
          "birthdate": "user.birthdate",
          "firstname": "user.firstname",
          "lastname": "user.lastname",
        }} 
       expected={{
            "address":  {
                "city": "user.address.city",
                "city": "user.address.city",
                "street": "user.address.city",
            },
            "id": 1,
            "birthdate": "user.birthdate",
            "firstname": "user.firstname",
            "lastname": "user.lastname",
        }}
    />
 </TestReport>

<Notes>

- Checks récup bon user

<br/>

- Mm chôse dump props user
- A nous comparer objets
- Dur localiser pb

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result).toBe(user2)
})
```

```diff 6 
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result.firstname).toBe(user2.firstname)
})
```

</CodeSurfer>

<Notes>

- Cherche vérifier bon user récupéré
- Comment distinguer deux users facilement -> firstname
- Transfo résult

</Notes>

---

<TestReport name="Gets user by id">
    <Matchers.ToEqual 
        actual="john"
       expected="bob"
    />
 </TestReport>

<Notes>

- Match test j'attendais user A, eu user B
- Aurait pu utiliser id, mais moins clair: 1 vs 2

</Notes>

---

<SplitBA 
    left={
    <TestReport name="Orders users by id descending">
        <Matchers.ToEqual 
            actual={[{
              "address":  {
                  "city": "user.address.city",
                  "city": "user.address.city",
                  "street": "user.address.city",
              },
              "id": 3,
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
              "lastname": "user.lastname",
            }]} 
           expected={[{
                "address":  {
                    "city": "user.address.city",
                    "city": "user.address.city",
                    "street": "user.address.city",
                },
                "id": 1,
                "birthdate": "user.birthdate",
                "firstname": "user.firstname",
                "lastname": "user.lastname",
            }]} />
    </TestReport>
    } 
    right={
    <TestReport name="Orders users by id descending">
        <Matchers.ToEqual actual={[1,2,3]} expected={[3,2,1]} />
     </TestReport>
    } 
/>

<Notes>

- Avant: 
- A nous de faire le travail
- Aucun indice sur le tri effectué (mauvais ordre ? pas de tri ? Quel item pose pb ?)
- Pourrait mm être un item manquant

<br/>

- Après:
- Comparaison immédiate et claire entre reçu et attendu
- Aucun effort à faire
- Mm sans lire nom pb évident -> attendais 3,2,1 reçu 1,2,3
 
</Notes>

---

<!--
****************************
****************************
** 👃 TRACE FAIL
****************************
****************************
-->

<Chapter emojis="🗺😢" title="Trace fail" />

<Notes>

- Echec localisation 

</Notes>

---

<TestReport name="Saves user to database">
    <Matchers.ToHaveBeenCalledWith 
        fnName="add()"
        actual={null}
        expected={{"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}}
    />
</TestReport>
 
<Notes>

- You just want to test delegation
- That something has been passed to something else
- Ex composant appelé avec bonnes props
- Cheks user ajouté db
- Via mock aka db.add appelé avec user
- Ici arg attendu pas clair (user)

</Notes>

---

<CodeSurfer>

```js 2,6,8
test(`Saves user in database c`, async () => {
    const user = makeUser()
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```js
test(`Saves user in database c`, async () => {
    const user = "user"
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

</CodeSurfer>

<Notes>

- Test utilise objet complet donc dump objet complet
- Mieux ? 
- Utilise pas user donc tank it
- remplace par tracer object/tracker aka identifiant

</Notes>

---

<TestReport name="Saves user to database">
    <Matchers.ToHaveBeenCalledWith 
        fnName="add()"
        actual={null}
        expected="user"
    />
</TestReport>
 
<Notes>

- Pas besoin lire objet pour comprendre attendu
- Parle language test "user" vs dump json
- Attendais add avec user  

</Notes>

---

<CodeSurfer>

```js showNumbers 2
test(`Saves user in database c`, async () => {
    const user = makeUser()
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```js showNumbers 
test(`Saves user in database c`, async () => {
    const user = withDescription(makeUser(), "user")
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```js showNumbers
const withDescription = (object, description) => {
  const copyWithCustomDescription = {
    ...object,
    toJSON: () => description
  } 
}
```

```js showNumbers 4
const withDescription = (object, description) => {
  const copyWithCustomDescription = {
    ...object,
    toJSON: () => description
  } 
}
```

</CodeSurfer>

<Notes>

- If object does matter
- Framework uses toJSON to display object
- Override it

</Notes>

---

<TestReport name="Saves user to database">
    <Matchers.ToHaveBeenCalledWith 
        fnName="add()"
        actual={null}
        expected="user"
    />
</TestReport>
 
<Notes>

- Possible utiliser objet
- Et profiter failure parlante

</Notes>

---

Use tracer objects

<Notes>

- Quand test délégation nommer objet attendu avec tracer

</Notes>

---

<SplitBA
 left={
<TestReport zoom={.7} name="Saves user to database">
    <Matchers.ToHaveBeenCalledWith 
        fnName="add()"
        actual={null}
        expected={{"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}}
    />
</TestReport>
 } 
 right={
    <TestReport zoom={.7} name="Saves user to database">
        <Matchers.ToHaveBeenCalledWith 
            fnName="add()"
            actual={null}
            expected="user"
        />
    </TestReport>
 } 
/>

<Notes>

- Avant: Devine user attendu avec combo add, db, props aident
- Sur objet plus abstrait, difficile (expected {get, add,})
- Après: Pas besoin deviner, sait quel objet attendu 


</Notes>

---

<Section title="Flexibility" emoji="🤸" />

<Notes>

- On a tests facile à aborder
- A comprendre
- Avec des erreurs utiles

<br/>

- Dernière étape assurer flexibles
- Test casse c'est pour bonne raison:
- Quand comportement change
- Pas quand refactor

</Notes>

---

<!--
****************************
****************************
** 👃 THE CREEP
****************************
****************************
-->

<Chapter emojis="🔎😏" title="The creep" />

<Notes>

- Le "creep"
- Le pervers
- Celui qui sait des chôses qui ne le regardent pas

</Notes>

---


<CodeSurfer>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```diff 3
```

```diff 5
```

```diff 7
```

```diff 
```


```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

```diff 1
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</CodeSurfer>

<Notes>

- Checks page passe en mode loading quand fetch données

<br/>

- View, mais test via détail implémentation vue (class sous jacente, methodes privées, fields)
- Sait trop. Sait comment fonctionne vue 
- Fragile, Will break on refactor of state/method
- (accessoirement Aucune valeur, not what we care about (aka showing a loader))


<br/>

- Test via public api, here, view
- Aka manière composant va etre utilisé
- Aucune connaissance logique sous jacente
- rename test (probablement language spec)

</Notes>

---

Test it the way you'll use it

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</Step>


<Step>

```diff 3[25:44],5[12:19],7[10:25]
```

```diff 4[200] 
```

</Step>



<Step>

```diff 5[200]
```

```diff 4[8:12],6[16:25]
```

</Step>

</CodeSurferColumns>


<Notes>

- Avant: utilise connaissance implémentation pour tester
- Donc si impl change, casse

<br/>

- Après: Test via public api
- Aka 0 connaissance fonctionnement interne 
- Protégé refactor
- Gagné en valeur au passage: Test peut pas passer si cassé pour utilisateur 

</Notes>

---

<Chapter emojis="📚😓" title="Overspecified" />

<Notes>

- Trop spécifié

</Notes>

---

<CodeSurfer>

```js showNumbers
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: `"Sku" is required`,
    price: `"Price" is required`,
  })
})
```

```diff 9:12
```

```diff 10[11:27],11[13:31]
```


```diff 
```

```js showNumbers
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: expect.any(String),
    price: expect.any(String),
  })
})
```

</CodeSurfer>

<Notes>

- Checks validateOrder liste toutes erreur validation

<br/>

- Veut vérifier toute clés en erreur présente
- Que chaque clé à erreur
- Implicitement on vérifie aussi l'erreur de validation (pas sa responsabilité)
- Peut paraitre banal mais pas de raison que test casse pour correction faute orth/update message 

<br/>

- Débarasser dépendance msg erreur (grand thème séction)
- Care about shape (string)
- Utiliser matcher permissif 

</Notes>

---

Only assert on what matters

<Notes>

- Vérifier seulement ce qui compte
// use loose matcher

</Notes>

--- 

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: `"Sku" is required`,
    price: `"Price" is required`,
  })
})
```

```js showNumbers subtitle="After"
test(`Lists all validation failures`, () => {
  const orderWithInvalidSkuAndPrice = makeOrder({
    sku: undefined,
    price: undefined
  }) 

  const report = validateOrder(orderWithInvalidSkuAndPrice)
  
  expect(report).toEqual({
    sku: expect.any(String),
    price: expect.any(String),
  })
})
```

</Step>

<Step>

```diff showNumbers subtitle="Before" 10[11:27],11[13:31]
```

```diff showNumbers subtitle="After" 6
```

</Step>

<Step>

```diff showNumbers subtitle="Before" 10[200]
```

```diff showNumbers subtitle="After" 10[10:27],11[12:29]
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant:
- Dépendance implicite sur le validateur
- Test casse pour détails non liés au test
- Si po change message, test fail

<br/>

- Apres:
- Dépendance cassée
- Détails peuvent changer mais tant que forme maintenue, test ok
- Cassera pour bonne raisons Ex: validateur retourne objet
- Aussi objectContaining, arrayContaing, ...

</Notes>

---

<!--
****************************
****************************
** 👃 REDUNDANT COVERAGE
****************************
****************************
-->

<Chapter emojis="🙈🙈" title="Redundant coverage" />

<Notes>

- Couverture de code redondante

</Notes>

---

<CodeSurfer>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```diff 2:3
```

```diff 2:4
```

```diff 5
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</CodeSurfer>

<Notes>

- Checks user validé par fournisseur identité ajouté db

<br/>

- Dépend des règles validation identity
- Probablement d'un lien db avec le ldap et l'ident
- Breaks if identity changes
- Test implicitement fonctionnement chaque collaborateur

<br/>

- Seule logique qui nous intéresse est celle à l'interieur repo
- Débarasser du reste
- Création frontiere/séparation interieur/exterieur (collabs)
- Mock validator
- Remove dependency on user
- Remove dependency on db

</Notes>

---

Enforce boundaries

<Notes>

- Limiter la surface de test

</Notes>

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</Step>

<Step>

```diff 2,3,4
```

```diff 3[200]
```

</Step>

<Step>

```diff 3[200]
```

```diff 2,3,4
```

</Step>

<Step>

```diff 3[200]
```

```diff 6
```

</Step>

</CodeSurferColumns>

<Notes>

- Avant: 
- Hérite règles validation Validateur identité
- Seed db
- Suspicious ldap

<br/>

- Après:
- Imposé limites avec exterieur (Remplacé collaborateurs par mocks)
- Donc limité debug area
- Gagné en controle (when(validator)>true)
- Plus compliqué à mairiser

</Notes>

---

🏗 + 💯 + 👌 + 🤸‍ = ❤️

<Notes>

- Structure 🏗
- Expressiveness 💯
- Feedback 👌
- Flexibility 🤸‍

</Notes>

---

Questions 🤓

---


<!--

desc
pb
how better ?
name refactor
B/A commentarytradeofs evaluation
-->
