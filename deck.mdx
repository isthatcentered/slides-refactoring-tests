import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {Image, Appear} from 'mdx-deck'
import { github, vsDark, shadesOfPurple, base } from "@code-surfer/themes";
import ciFailBadNamingSrc from "./static/test_with_bad_naming_run_fail.png"
import image from "./src/components/image"
import TestReport, { Matchers } from "./src/components/test-report"
import {Inline, Caption, Figure, EmojiSlide, TestsVsDevKnowledgeTable } from "./src/components"
export const theme = base;
import "./src/styles.css"
import "typeface-gothic-a1"
export const splitCodeSampleProps = {themes: [vsDark, base]}


# Readable tests

---

<EmojiSlide caption="Clean code">
🛀📝
</EmojiSlide>  

<Notes>

- Tous les jours importance clean code

</Notes>

---

<EmojiSlide caption="Our code">  
<ul>
    <li>🤱</li>
    <Appear>
        <li key="1">🤏</li>
        <li key="2">👶</li>
        <li key="3">🌹</li>
    </Appear>
</ul>
</EmojiSlide>


<Notes>

- Prendre soin code
- Méthodes courtes
- Renommer encore methodes, class, variable 
- Jusqu''à ce que ça se lise comme poésie
- Et puis pourtants fichiers test:

</Notes>

---

<CodeSurfer>

```ts showNumbers
test("<Signup/>", async () => {
    const navigateSpy = jest.fn()
    ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
        () => navigateSpy,
    )
    ;((User.createUser as any) as jest.MockInstance<
        ReturnType<typeof User.createUser>,
        any
    >).mockResolvedValue(null as any)
    ;((SocialLogin as any) as jest.MockInstance<
        ReturnType<typeof SocialLogin>,
        any
    >).mockImplementation(() => null)
    
    const page = render(<Signin />)
    
    const submitButton = page.getByRole("button", {
        name: /signin/i,
    }) as HTMLButtonElement
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Login & password required/i)).not.toThrow()
    
    const email = page.getByLabelText(/email/i)
    fireEvent.change(email, { target: { value: "john@gmail.com" } })
    
    const password = page.getByLabelText(/password/i)
    fireEvent.change(password, { target: { value: "helloworld" } })
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Loading/i)).not.toThrow()
    expect(submitButton.disabled).toBe(true)
    
    expect(User.createUser).toHaveBeenCalledWith({
        email: "john@gmail.com",
        password: "helloworld",
    })
    
    await tick()
    
    expect(navigateSpy).toHaveBeenCalledWith("/")
    
    expect(SocialLogin).toHaveBeenLastCalledWith(
        {
            loginEnpointRootUrl: API_BASE_URL,
        } as PropsType<typeof SocialLogin>,
        {},
    )

    // ... more
})
```

</CodeSurfer>

---

<EmojiSlide caption="I quit">  
    🏃‍♂️
</EmojiSlide>

<Notes>

- Moment ou souvient 18h, piscine, time to go home

</Notes>


---

# Refactoring tests

<Appear>
    <p>But why though ?</p>
</Appear>  

<Notes>

- Why
- J'ai des tests c'et pas suffisant ?

</Notes>

---



<EmojiSlide caption="Tests are a runnable specification">
🏃‍♂️📚
</EmojiSlide>  

<Notes>

- tests = spec executable
- Source de vérité:
- Comment chaque ecran app doit se comporter
- comment chaque edge case doit être géré

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩" tests="📚" result="😀" />

<Notes>

- Lors ajout feature/refactor 
- Permet concentrer / feature only
- Test watches for you
- = Avance + vite
- = + features
- = - bugs

<br/>

- Problème arrive quand deadline
- Par défaut Test = premier truc à sauter
- Donc refactor bc Si dur à aborder, tchao direct

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩📕" tests="📗📘" result="😐" />

<Notes>

- test en moins = pièce en plus
- cas erreur feature + cas erreur test supprimé

</Notes>

---


<TestsVsDevKnowledgeTable dev="🧩📕📗" tests="📘" result="😓" />

<Notes>

- Et à chaque test en moins doit garder + en + en mémoire 
- tendence inversée + en tête que ds tests
- 2 pas arrières pour 1 en avant

</Notes>

---

<TestsVsDevKnowledgeTable dev="🧩📚" tests="" result="🤯" />

<Notes>

- Jusque moment ou tendance complètement inversée
- A chaque changement doit tout vérifier 
- impossible toute app en tête 

</Notes>

---

<EmojiSlide>
    <span>
        📈
    </span>
    <Appear>
        <span>
        😤 
        </span>
        <span>💸</span>
    </Appear>
</EmojiSlide>

<Notes>

- Can't keep all that in mind
- So bugs
- frutrated users
- lost money

</Notes>

---

<EmojiSlide>
    <span>
    👃
    </span>
    <Appear>
     <span>→ 👷‍♂️</span>
    </Appear>
</EmojiSlide>
  
<Notes>

- but aujourd'hui: 
- Identifier smells qui font test difficile maintenir
- Voir pistes pour faire mieux
- combo smell -> refactor

</Notes>

---

// logo JS

<Notes>

- Aptable à n'importe quel language
- Probleme -> piste possible pour le résoudre
- Donc important = principe
- La façon dont fait et juste une piste possible

</Notes>

   
<!-- 
🏗 + 💯 + 👌 + 🤸‍
- Structure 🏗
- Expressiveness 💯
- Feedback 👌
- Flexibility 🤸‍
-->

---


<EmojiSlide caption="Structural smells">🏗</EmojiSlide>


<Notes>

- Structure

- Veut contribution facile sous pression

- Impossible si chaque test réinvente la roue (naming, organisation, strategie)

- Voyage héros (HP, Roi lien, Matrix, Seigneur anneaux)

- Détails différents mais structure est la même

- Est-ce qu'on peut faire pareil

</Notes>

--- 

<!--
****************************
****************************
** 👃 UFOCUSED TESTS
****************************
****************************
-->

<EmojiSlide caption="Unfocused test">
🕺✅
</EmojiSlide>  

<Notes>

- Test qui part dans tous les sens

</Notes>

---

<CodeSurfer>

```js  showNumbers
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff 6,11 showNumbers
```

```diff 5,8,10 showNumbers
```

```diff 2:4,7,9
```

```diff 
```

```js showNumbers 2:6 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  type(password, "credentials.password")
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 7:9 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6 10:11 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff showNumbers 2:6 subtitle="Arrange"
```

```diff showNumbers 7:9 subtitle="Act"
```

```diff showNumbers 10:11 subtitle="Assert"
```

```diff showNumbers 2:6 subtitle="Given"
```

```diff showNumbers 7:9 subtitle="When"
```

```diff showNumbers 10:11 subtitle="Then"
```

```js showNumbers 1:14
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```


```diff 12  
```

```diff showNumbers 2:6,8:10,13  
```

```diff showNumbers  3,6,12
```

</CodeSurfer>

<Notes>

- Vérifie redirigé vers page d'accueil quand on se log

<br/>

- Qu'est-ce qui fait test compliqué ?
- Fouilli 
- Quand test fail, et besoin + infos
- check assertions -> actions -> arrange
- Ici, sont cachées, Mélange: [setup][actions][vérification]
- En gros, dur à suivre

<br/>

- Comment rendre plus clair ?
- Grouper par type  
- + add spaces
- SIGNAL: 2 AAA

</Notes>

---

Arrange, Act, Assert 

<Notes>

- AAA

</Notes>

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers subtitle='After'
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Si failure
- Peux localiser rapidement assertions et remonter
- Pas besoin de chercher
- Accessoirement, spaces = fais mois peur 

</Notes>

---

<!--
****************************
****************************
** 👃 JUNK DRAWER
****************************
****************************
-->

👃: Junk drawer (🗑🗄)

<Notes>

- Fourre tout

</Notes>

---

<CodeSurfer>

```js showNumbers
test("<LoginPage/>", () => {
  // ...
}) 
```

```js showNumbers
test("<LoginPage/>", () => {
  // verify can't submit if empty form

  // verify email validation
  
  // Verify password validation
    
  // verify loading state
    
  // verify login fail displays error
    
  // verify login fail redirect error

  // more stuff
}) 
```

```js 1[6:39]
test("method -> condition -> behavior", ()=>{})
```

```js 1[6:18]
test("<LoginPage/> -> condition -> behavior", ()=>{})
```

```js 1[23:35]
test("<LoginPage/> -> failed login -> behavior", ()=>{})
```

```js 1[39:60]
test("<LoginPage/> -> failed login -> displays server error", ()=>{})
```

```js 1[7:54]
test("<LoginPage/> failed login displays server error", ()=>{})
```

```js 
describe("<LoginPage/>", () => {
  test("Failed login displays server error", ()=>{})
}) 
```

```js 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=>{})
  test("Pending submission displays loader", ()=>{})
  test("Successful login redirects to dashboard", ()=>{})
}) 
```

```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {}) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {
    test("Displays server error", ()=>{})
    test("Requires captcha on subsequent attempts", ()=>{})
    //...
  }) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

</CodeSurfer>

<Notes>

- Juste 1 test ?
- Suspect
- Comment faire mieux ?
- Scoper via convention nommage

</Notes>


---

# Use naming to scope

---

<CodeSurferColumns  {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="before"
test("<LoginPage/>", () => {
    // verify can't submit if empty form
    
    // verify email validation
    
    // Verify password validation
    
    // verify loading state
    
    // verify login fail displays error
    
    // verify login fail redirect error
    
    // more stuff
}) 
```

```js subtitle="After" 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=> {})
  test("Pending submission displays loader", ()=> {})
  test("Successful login redirects to dashboard", ()=> {})
}) 
```

</Step> 

</CodeSurferColumns>  

<Notes>

- Part d'un test dump
- Set tests concentrés sur pb unique
- We probably surfaced more edge cases

</Notes> 

---

"I don't care"

<Notes>

- Au delà difficulté à aborder test
- Side effect = useless ci

</Notes>

---

<TestReport name="<LoginPage/>" >
    <span style={{color:"lightgray"}}>// Some random error</span>
</TestReport>

<Notes>

- Guess what the error is when you broke:
- Validation ?
- Redirection ?
- Error message ? 
- Yup

</Notes>

---

<TestReport name="<LoginPage/> Successful login redirects to dashboard" >
    <span style={{color:"lightgray"}}>// Some error that makes more sense now</span>
</TestReport>

<Notes>

- Can start investigating right away

</Notes>

---

<!--
****************************
****************************
** 👃 Unicorns everywhere
****************************
****************************
-->

👃: Unicorns everywhere (🦄🗺)


<Notes>

- Chaque test = licorne/réinvente la roue

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

<Step>

```diff 2:4,9 subtitle="Real collaborators"
```

```diff
```

</Step>

<Step>

```diff 
```

```diff 2:4,6,10 subtitle="Mocks only"
```

</Step>

<Step>

```diff 4,7,9
```

```diff 4,8,10
```

</Step>

<Step>

```diff 
```

```diff 
```

</Step>

</CodeSurferColumns>

<Notes>

- 2 tests font exactement mm chose
- Prend truc, ajout, verifie ajouté
- Dur Contribuer
- Suite 10 tests chacun complètement différent
- Comment faire mieux ?

</Notes>   

---


Stick to your guns

<Notes>

- Aka même type d'objet, même type de test

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
    const db = { add: jest.fn() }
    const validator = { allows: jest.fn() }
    const user = "user"
    const repository = new ProductsRepository(db, validator)
    validator.mockResolvedValue(true)
    
    await repository.add(user)
    
    expect(db.add).toHaveBeenCalledWith("users", user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

</CodeSurferColumns>

<Notes>

- Choisit strategie test et on s'y colle
- Ici test services via mock 

</Notes>

---

<!--
*****************************************************************************
*****************************************************************************
** Expressiveness 💯 *********************************************************
*****************************************************************************
*****************************************************************************
-->

# Expressiveness 💯

<Notes>

- Manque expressivité 

<br/>
- Veut test maintenable
- Travaillé structure = capable trouver marque rapidement/nouveau test
- Etape suivant = arriver à comprendre ce qui se passe
- Trouver bon niveau de détail pour compréhension rapide
- Mettre en valeur ce qui importance dans test
- Cacher le reste

</Notes>

--- 

<!--
****************************
****************************
** 👃 LOST IN DETAILS
****************************
****************************
-->

👃: Lost in details (📚🤔)

---

<CodeSurfer>

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 12:17 showNumbers
```

```diff 7,12:14 showNumbers 
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 1[30:34]
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 25
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 31
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 30:33
```

```diff 28 
```

```diff 30:31 
```

```diff 32:33
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue()

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue()

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</CodeSurfer>

<Notes>

- 5 sec to tell me what this is doing
- Compliqué alors que peu de lignes
- Pièces bas niveau cachent concept global
- How can we make that better ?

<br/>

- Framework is not for you
- Compose low level pieces into helpers
- Create page/item specific helpers to match domain
- Create interactor/page obejct

</Notes>

---

What, not how

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 7:17 subtitle="Before" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6:10 subtitle="After" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Easy to understand
- Domain terms
- Centralized knowledge (bonus)

</Notes>

--- 

<!--
****************************
****************************
** 👃 SUSPICIOUS VALUES
****************************
****************************
-->

👃: Suspicious values (👮‍♂️📦)

<Notes>

- Valeurs suspectes

</Notes>

---

<CodeSurfer>

```js showNumbers
const count = 2
```

```js showNumbers
const date = "20/03/2018"
```

```js showNumbers 3:4 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers
    const route = WHATEVER
    const service = new SomeService(route)

    service.methodThatDoesntUseRoute()
```

</CodeSurfer>


<Notes>

- Why 2, why not 1
- And why not 0
- Whay "20/03/2018" why not 21st ?
- Does it really have to be a valid email ?
- If data shape doesn't matter, show it (credentials.email)
- If value doesn't matter at all, show it (WHATEVER) 

</Notes>

---

Make the unimportant obviously unimportant

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Clear that the value shape doesn't matter for this test
- If expectation on value passing, you'll get a better message (tracer object)

</Notes>

---

<!--
****************************
****************************
** 👃 EVERYTHING BOLD
****************************
****************************
-->

👃: Everything bold (🌏👨‍🦲)

---

<CodeSurfer>

```js showNumbers
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 2:7
```

```diff 9
```

```diff
```

```js showNumbers subtitle="Factory"
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 12:13
```

```js showNumbers subtitle="Named factory"
test("Valiation success adds user to repository", () => {
    const user =  makeUser.approvedByIdentity()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</CodeSurfer>

<Notes>

- What in this user makes this test pass/fail
- I see a validator, so there's probably something going on
- I should be able to tell what
- How can we make that more obvious

</Notes>

---

Highlight what matters

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:8
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** 👃 Duplicate naming
****************************
****************************
-->

👃: Duplicate naming (👶👶)

---

<CodeSurfer>

```js showNumbers
// Calls do something
doSomething()
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const identityApprovedUser =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```diff 2:7
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</CodeSurfer>

---

Put naming to work

--- 

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2[11:16],5[11:16],16
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** 👃 MYSTERY GUEST
****************************
****************************
-->

👃: Mystery guest (👻🎁)

<Notes>

- L'invité mystère

</Notes>

---


<CodeSurfer>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```diff 5[40:45]
```

```js
// fixtures/db/users.json
[
  {
    name: "John"
    // ...other props
  },
  // ...other users 
]
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

```diff 2:3
```

```diff 7:8
```

```diff 11[10:21,28:41]
```

</CodeSurfer>


<Notes>

- Check récupère premier item dans table
- The fuck did john come from ?!
- Qq'un forcement changer propriété et tout casser
- Cas ou mutation fixtures dans appli legacy -> 3 jours debug

<br/>

- Assume DB starts empty + reset
- On sait ou vient nom
- controle donnée

</Notes>

---

Control your data

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

</Step>


<Step>

```diff 4
```

```diff 2:11
```

</Step>

<Step>

```diff 5[40:46]
```

```diff 2,11[28:42]
```

</Step>

</CodeSurferColumns>

<Notes>

- Plus long
- Mais pas risque intervention divine
- Controle mes données
- Peut tracer d'ou vient valeur attendue

</Notes>

---

Feedback 👌 

<Notes>

- When fail, in ci/during refactor 
- Don't want to waste time understanding failure
- Failure should be expressive enough to tell you clearly what was expected and what happened
- Otherwise, time lost 
- Like undefined is not a function
- True, but I still have no clue what the problem is
- Failures should give you clues, breadcrumbs on the path to solving a bug
see justin searls

</Notes>

---

<!--
****************************
****************************
** 👃 NAN
****************************
****************************
-->

👃: Not a number (🎰)

<Notes>

- Ever had that error
- Not quite useful right 
- Like undefined is not a function
- True, but I still have no clue what the problem is

</Notes>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToBe actual={5} expected={0} />
</TestReport>

---

<CodeSurfer>

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string).length).toBe(5)
})
```

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string)).toHaveLength(5)
})
```

</CodeSurfer>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToHaveLength actual={0} expected={10} passed={[]} />
</TestReport>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBe actual={false} expected={true} />
</TestReport>

---

<CodeSurfer>

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button.disabled).toBe(true)
})
```

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button).toBeDisabled()
})
```

</CodeSurfer>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBeDisabled />
</TestReport>

---

Leverage matchers

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```bash 
🛑 Fail: "chars() returns every char in string"
        
         Error: expected( 0 ).toBe( 5 ) 
```

```bash 
🛑 Fail: "chars() returns every char in string"
        
         Error: expect(received).toHaveLength(expected)
         
         Expected length: 10
         Received length: 0
         Received array:  []
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** 👃 Memory dump
****************************
****************************
-->

👃: Memory dump (🧠🗑)

<Notes>


</Notes>

---

<CodeSurfer>

```bash
🛑 Fail: "Returns users sorted by id descending"
        Error: expect(received).toEqual(expected) // deep equality
        
        - Expected
        + Received
        
        @@ -4,11 +4,11 @@
                "city": "user.address.city",
                "street": "user.address.city",
              },
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
        -     "id": 3,
        +     "id": 1,
              "lastname": "user.lastname",
            },
            Object {
              "address": Object {
                "city": "user.address.city",
        @@ -24,9 +24,9 @@
                "city": "user.address.city",
                "street": "user.address.city",
              },
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
        -     "id": 1,
        +     "id": 3,
              "lastname": "user.lastname",
            },
          ]
```

```js showNumbers
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users)

  expect(result).toEqual([user3, user2, user1])
})
```

```js showNumbers 
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users).map(prop("id"))
  
  expect(result).toEqual([3, 2, 1])
})
```

```diff 4[35:51],6[26:35]
```

```bash
🛑 Fail: "Returns users sorted by id descending"
        Error: expect(received).toEqual(expected) // deep equality
        
        - Expected
        + Received
        
          Array [
        -   3,
        -   2,
            1,
        +   2,
        +   3,
          ]
```

```bash
🛑 Fail: "Gets user by id"
        Error: expect(received).toBe(expected) // Object.is equality
        
        - Expected
        + Received
        
        @@ -2,9 +2,9 @@
            "address": Object {
              "city": "user.address.city",
              "street": "user.address.city",
            },
            "birthdate": "user.birthdate",
        -   "firstname": "John",
        -   "id": 2,
        +   "firstname": "Bob",
        +   "id": 1,
            "lastname": "user.lastname",
          }
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result).toBe(user2)
})
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result.firstname).toBe(user2.firstname)
})
```

```bash
🛑 Fail: "Gets user by id"
        Error: expect(received).toBe(expected) // Object.is equality
        
        Expected: "John"
        Received: "Bob"
```

</CodeSurfer>

---

<!--
****************************
****************************
** 👃 TRACE FAIL
****************************
****************************
-->

👃: Trace fail (🗺😢)

<Notes>

- You just want to test delegaton
- That something has been passed to something else

</Notes>

---

<CodeSurfer>

```bash
🛑 Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: {"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}
        Received: undefined
```

```js 2,6,8
test(`Saves user in database c`, async () => {
    const user = withDescription(makeUser(), "user")
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```js
test(`Saves user in database c`, async () => {
    const user = "user"
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```bash
🛑 Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: "user"
        Received: undefined
```

</CodeSurfer>

---

Use placeholders

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```bash
🛑 Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: {"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}
        Received: undefined
```

```bash
🛑 Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: "user"
        Received: undefined
```

</Step>

</CodeSurferColumns>

---

<EmojiSlide caption="Flexibility">🤸‍</EmojiSlide>

<Notes>

make test xp easy
tests shouldn't break unless behavior changed
tests shouldn't break because a collaborator broke only break for relevant reasons
shouldn't feel like dying because you're adding one param to the constructor and have to update 15 tests
shouldn't break because another part of the spec for this method has changed (objectMatchig)

</Notes>

---

<!--
****************************
****************************
** 👃 THE CREEP
****************************
****************************
-->

<EmojiSlide caption="The creep">🔎😏</EmojiSlide>  

---


<CodeSurfer>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```diff 3
```

```diff 7
```

```diff 5[12:19]
```

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</CodeSurfer>
<Notes>

- Checks state loading once started fetching page data

<br/>

- This is a view but
- Assertion on internal state
- Via private method 
- Fragile: Will break on refactor of state/method
- Not what we care about (aka showing a loader)

<br/>

- Test via public api, here, view
- rename test

</Notes>

---

Test it the way you'll use it

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</Step>


<Step>

```diff 3[25:44],5[12:19],7[10:25]
```

```diff 4[8:12],6[16:25]
```

</Step>

<Step>

```diff 1[7:45]
```

```diff 1[7:39]
```

</Step>

</CodeSurferColumns>


<Notes>

- Language totally different (instance, getData vs click, hasText)
- Protected from refactor
- Actually tests what matters
- Test name matches spec

</Notes>

---

<!--
****************************
****************************
** 👃 Overspecified
****************************
****************************
-->

<EmojiSlide caption="Overspecified">📚😓</EmojiSlide>

---

<CodeSurfer>

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: `"Invalid email" is not a valid email`
    }, 
    count: 1
  })
})
```

```diff 9:14
```

```diff 11[14:52]
```

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: expect.any(String)
    }, 
    count: 1
  })
})
```

```diff 13
```

```js 9:13
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toMatchObject({
    errors: {
      email: expect.any(String)
    }
  })
})
```

</CodeSurfer>

<Notes>

- Verifies validation report matches expectations

<br/>

- Only care about shape of error
- Yet assertion on everything
- What if new key in report/rename count to total
- Breaks for unrelated reasons
- Depends on email validation msg

<br/>

comment faire mieux
- Don't depend on external obj behavior (email)
- Only assert on part that matters, ignore the rest

nom refactor
B/A

</Notes>

---

Assert only on what matters to the test

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: `"Invalid email" is not a valid email`
    }, 
    count: 1
  })
})
```

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toMatchObject({
    errors: {
      email: expect.any(String)
    }
  })
})
```

</Step>

<Step>

```diff 6
```

```diff 9[18:32],10:13
```

</Step>

</CodeSurferColumns>


<Notes>

- Précisé assertions
- Enlevé dépendance comportement email
- Peut changer forme report sans risque
- Attention matcher permissif, si vous attendiez clé

</Notes>

---

<!--
****************************
****************************
** 👃 REDUNDANT COVERAGE
****************************
****************************
-->

<EmojiSlide caption="Redundant coverage">
🙈🙈
</EmojiSlide>

---

<CodeSurfer>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```diff 3
```

```diff 2:4
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</CodeSurfer>

<Notes>

- Checks valid user added to db

<br/>

- Dépend des règles validation identity
- Probablement d'un lien db avec le ldap et l'ident
- Breaks if identity changes

<br/>

- Création frontiere/séparation interieur/exterieur (collabs)
- Mock validator
- Remove dependency on user
- Remove dependency on db

</Notes>

---

Enforce boundaries

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</Step>

<Step>

```diff 2,3,4
```

```diff 
```

</Step>

<Step>

```diff 
```

```diff 2,3,4
```

</Step>

<Step>

```diff 
```

```diff 6
```

</Step>

</CodeSurferColumns>

<Notes>

- Imposé limites
- Clair que si bug c'est pas dans les collabs
- Small debug area
- Controle collabs, pas besoin trouver ldap invalide
- Plus compliqué à mairiser

</Notes>



<!--

desc
pb
how better ?
name refactor
B/A commentarytradeofs evaluation
-->
