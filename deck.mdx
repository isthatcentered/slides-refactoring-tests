import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import {Image, Appear} from 'mdx-deck'
import { github, vsDark, shadesOfPurple, base } from "@code-surfer/themes";
import ciFailBadNamingSrc from "./static/test_with_bad_naming_run_fail.png"
import image from "./src/components/image"
import TestReport, { Matchers } from "./src/components/test-report"
import {Inline, Caption, Figure, EmojiSlide, TestsVsDevKnowledgeTable } from "./src/components"
export const theme = base;
import "./src/styles.css"
import "typeface-gothic-a1"
export const splitCodeSampleProps = {themes: [vsDark, base]}


# Readable tests

---

<EmojiSlide caption="Clean code">
ğŸ›€ğŸ“
</EmojiSlide>  

<Notes>

- Tous les jours importance clean code

</Notes>

---

<EmojiSlide caption="Our code">  
<ul>
    <li>ğŸ¤±</li>
    <Appear>
        <li key="1">ğŸ¤</li>
        <li key="2">ğŸ‘¶</li>
        <li key="3">ğŸŒ¹</li>
    </Appear>
</ul>
</EmojiSlide>


<Notes>

- Prendre soin code
- MÃ©thodes courtes
- Renommer encore methodes, class, variable 
- Jusqu''Ã  ce que Ã§a se lise comme poÃ©sie
- Et puis pourtants fichiers test:

</Notes>

---

<CodeSurfer>

```ts showNumbers
test("<Signup/>", async () => {
    const navigateSpy = jest.fn()
    ;(useNavigate as jest.Mock<typeof useNavigate>).mockImplementation(
        () => navigateSpy,
    )
    ;((User.createUser as any) as jest.MockInstance<
        ReturnType<typeof User.createUser>,
        any
    >).mockResolvedValue(null as any)
    ;((SocialLogin as any) as jest.MockInstance<
        ReturnType<typeof SocialLogin>,
        any
    >).mockImplementation(() => null)
    
    const page = render(<Signin />)
    
    const submitButton = page.getByRole("button", {
        name: /signin/i,
    }) as HTMLButtonElement
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Login & password required/i)).not.toThrow()
    
    const email = page.getByLabelText(/email/i)
    fireEvent.change(email, { target: { value: "john@gmail.com" } })
    
    const password = page.getByLabelText(/password/i)
    fireEvent.change(password, { target: { value: "helloworld" } })
    
    fireEvent.click(submitButton)
    
    expect(() => page.getByText(/Loading/i)).not.toThrow()
    expect(submitButton.disabled).toBe(true)
    
    expect(User.createUser).toHaveBeenCalledWith({
        email: "john@gmail.com",
        password: "helloworld",
    })
    
    await tick()
    
    expect(navigateSpy).toHaveBeenCalledWith("/")
    
    expect(SocialLogin).toHaveBeenLastCalledWith(
        {
            loginEnpointRootUrl: API_BASE_URL,
        } as PropsType<typeof SocialLogin>,
        {},
    )

    // ... more
})
```

</CodeSurfer>

---

<EmojiSlide caption="I quit">  
    ğŸƒâ€â™‚ï¸
</EmojiSlide>

<Notes>

- Moment ou souvient 18h, piscine, time to go home

</Notes>


---

# Refactoring tests

<Appear>
    <p>But why though ?</p>
</Appear>  

<Notes>

- Why
- J'ai des tests c'et pas suffisant ?

</Notes>

---



<EmojiSlide caption="Tests are a runnable specification">
ğŸƒâ€â™‚ï¸ğŸ“š
</EmojiSlide>  

<Notes>

- tests = spec executable
- Source de vÃ©ritÃ©:
- Comment chaque ecran app doit se comporter
- comment chaque edge case doit Ãªtre gÃ©rÃ©

</Notes>

---

<TestsVsDevKnowledgeTable dev="ğŸ§©" tests="ğŸ“š" result="ğŸ˜€" />

<Notes>

- Lors ajout feature/refactor 
- Permet concentrer / feature only
- Test watches for you
- = Avance + vite
- = + features
- = - bugs

<br/>

- ProblÃ¨me arrive quand deadline
- Par dÃ©faut Test = premier truc Ã  sauter
- Donc refactor bc Si dur Ã  aborder, tchao direct

</Notes>

---

<TestsVsDevKnowledgeTable dev="ğŸ§©ğŸ“•" tests="ğŸ“—ğŸ“˜" result="ğŸ˜" />

<Notes>

- test en moins = piÃ¨ce en plus
- cas erreur feature + cas erreur test supprimÃ©

</Notes>

---


<TestsVsDevKnowledgeTable dev="ğŸ§©ğŸ“•ğŸ“—" tests="ğŸ“˜" result="ğŸ˜“" />

<Notes>

- Et Ã  chaque test en moins doit garder + en + en mÃ©moire 
- tendence inversÃ©e + en tÃªte que ds tests
- 2 pas arriÃ¨res pour 1 en avant

</Notes>

---

<TestsVsDevKnowledgeTable dev="ğŸ§©ğŸ“š" tests="" result="ğŸ¤¯" />

<Notes>

- Jusque moment ou tendance complÃ¨tement inversÃ©e
- A chaque changement doit tout vÃ©rifier 
- impossible toute app en tÃªte 

</Notes>

---

<EmojiSlide>
    <span>
        ğŸ“ˆ
    </span>
    <Appear>
        <span>
        ğŸ˜¤ 
        </span>
        <span>ğŸ’¸</span>
    </Appear>
</EmojiSlide>

<Notes>

- Can't keep all that in mind
- So bugs
- frutrated users
- lost money

</Notes>

---

<EmojiSlide>
    <span>
    ğŸ‘ƒ
    </span>
    <Appear>
     <span>â†’ ğŸ‘·â€â™‚ï¸</span>
    </Appear>
</EmojiSlide>
  
<Notes>

- but aujourd'hui: 
- Identifier smells qui font test difficile maintenir
- Voir pistes pour faire mieux
- combo smell -> refactor

</Notes>

---

// logo JS

<Notes>

- Aptable Ã  n'importe quel language
- Probleme -> piste possible pour le rÃ©soudre
- Donc important = principe
- La faÃ§on dont fait et juste une piste possible

</Notes>

   
<!-- 
ğŸ— + ğŸ’¯ + ğŸ‘Œ + ğŸ¤¸â€
- Structure ğŸ—
- Expressiveness ğŸ’¯
- Feedback ğŸ‘Œ
- Flexibility ğŸ¤¸â€
-->

---


<EmojiSlide caption="Structural smells">ğŸ—</EmojiSlide>


<Notes>

- Structure

- Veut contribution facile sous pression

- Impossible si chaque test rÃ©invente la roue (naming, organisation, strategie)

- Voyage hÃ©ros (HP, Roi lien, Matrix, Seigneur anneaux)

- DÃ©tails diffÃ©rents mais structure est la mÃªme

- Est-ce qu'on peut faire pareil

</Notes>

--- 

<!--
****************************
****************************
** ğŸ‘ƒ UFOCUSED TESTS
****************************
****************************
-->

<EmojiSlide caption="Unfocused test">
ğŸ•ºâœ…
</EmojiSlide>  

<Notes>

- Test qui part dans tous les sens

</Notes>

---

<CodeSurfer>

```js  showNumbers
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff 6,11 showNumbers
```

```diff 5,8,10 showNumbers
```

```diff 2:4,7,9
```

```diff 
```

```js showNumbers 2:6 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  type(password, "credentials.password")
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 7:9 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6 10:11 
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)
  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```diff showNumbers 2:6 subtitle="Arrange"
```

```diff showNumbers 7:9 subtitle="Act"
```

```diff showNumbers 10:11 subtitle="Assert"
```

```diff showNumbers 2:6 subtitle="Given"
```

```diff showNumbers 7:9 subtitle="When"
```

```diff showNumbers 10:11 subtitle="Then"
```

```js showNumbers 1:14
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```


```diff 12  
```

```diff showNumbers 2:6,8:10,13  
```

```diff showNumbers  3,6,12
```

</CodeSurfer>

<Notes>

- VÃ©rifie redirigÃ© vers page d'accueil quand on se log

<br/>

- Qu'est-ce qui fait test compliquÃ© ?
- Fouilli 
- Quand test fail, et besoin + infos
- check assertions -> actions -> arrange
- Ici, sont cachÃ©es, MÃ©lange: [setup][actions][vÃ©rification]
- En gros, dur Ã  suivre

<br/>

- Comment rendre plus clair ?
- Grouper par type  
- + add spaces
- SIGNAL: 2 AAA

</Notes>

---

Arrange, Act, Assert 

<Notes>

- AAA

</Notes>

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="Before"
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  type(email, "credentials.email")
  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  const password = page.getByLabel(/password/i)
  type(password, "credentials.password")
  const submitButton = page.getByLabel(/submit/i)
  click(submitButton)
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

```js showNumbers subtitle='After'
test("<LoginPage/>", () => {
  const navigateSpy = spyOn(navigate)
  const page = render(<LoginPage/>)
  const email = page.getByLabel(/email/i)
  const password = page.getByLabel(/password/i)
  const submitButton = page.getByLabel(/submit/i)

  type(email, "credentials.email")
  type(password, "credentials.password")
  click(submitButton)

  expect(page.getByLabel(/submit/i)).not.ToBeInDom()
  expect(navigateSpy).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Si failure
- Peux localiser rapidement assertions et remonter
- Pas besoin de chercher
- Accessoirement, spaces = fais mois peur 

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ JUNK DRAWER
****************************
****************************
-->

ğŸ‘ƒ: Junk drawer (ğŸ—‘ğŸ—„)

<Notes>

- Fourre tout

</Notes>

---

<CodeSurfer>

```js showNumbers
test("<LoginPage/>", () => {
  // ...
}) 
```

```js showNumbers
test("<LoginPage/>", () => {
  // verify can't submit if empty form

  // verify email validation
  
  // Verify password validation
    
  // verify loading state
    
  // verify login fail displays error
    
  // verify login fail redirect error

  // more stuff
}) 
```

```js 1[6:39]
test("method -> condition -> behavior", ()=>{})
```

```js 1[6:18]
test("<LoginPage/> -> condition -> behavior", ()=>{})
```

```js 1[23:35]
test("<LoginPage/> -> failed login -> behavior", ()=>{})
```

```js 1[39:60]
test("<LoginPage/> -> failed login -> displays server error", ()=>{})
```

```js 1[7:54]
test("<LoginPage/> failed login displays server error", ()=>{})
```

```js 
describe("<LoginPage/>", () => {
  test("Failed login displays server error", ()=>{})
}) 
```

```js 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=>{})
  test("Pending submission displays loader", ()=>{})
  test("Successful login redirects to dashboard", ()=>{})
}) 
```

```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {}) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

```js 
describe("<LoginPage/>", () => {
  describe("Failed login", () => {
    test("Displays server error", ()=>{})
    test("Requires captcha on subsequent attempts", ()=>{})
    //...
  }) 
  describe("Invalid form", () => {})
  describe("Successful login", () => {})
}) 
```

</CodeSurfer>

<Notes>

- Juste 1 test ?
- Suspect
- Comment faire mieux ?
- Scoper via convention nommage

</Notes>


---

# Use naming to scope

---

<CodeSurferColumns  {...splitCodeSampleProps}>

<Step>

```js showNumbers subtitle="before"
test("<LoginPage/>", () => {
    // verify can't submit if empty form
    
    // verify email validation
    
    // Verify password validation
    
    // verify loading state
    
    // verify login fail displays error
    
    // verify login fail redirect error
    
    // more stuff
}) 
```

```js subtitle="After" 
describe("<LoginPage/>", () => {
  test("Invalid credentials displays server error", ()=> {})
  test("Pending submission displays loader", ()=> {})
  test("Successful login redirects to dashboard", ()=> {})
}) 
```

</Step> 

</CodeSurferColumns>  

<Notes>

- Part d'un test dump
- Set tests concentrÃ©s sur pb unique
- We probably surfaced more edge cases

</Notes> 

---

"I don't care"

<Notes>

- Au delÃ  difficultÃ© Ã  aborder test
- Side effect = useless ci

</Notes>

---

<TestReport name="<LoginPage/>" >
    <span style={{color:"lightgray"}}>// Some random error</span>
</TestReport>

<Notes>

- Guess what the error is when you broke:
- Validation ?
- Redirection ?
- Error message ? 
- Yup

</Notes>

---

<TestReport name="<LoginPage/> Successful login redirects to dashboard" >
    <span style={{color:"lightgray"}}>// Some error that makes more sense now</span>
</TestReport>

<Notes>

- Can start investigating right away

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ Unicorns everywhere
****************************
****************************
-->

ğŸ‘ƒ: Unicorns everywhere (ğŸ¦„ğŸ—º)


<Notes>

- Chaque test = licorne/rÃ©invente la roue

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

<Step>

```diff 2:4,9 subtitle="Real collaborators"
```

```diff
```

</Step>

<Step>

```diff 
```

```diff 2:4,6,10 subtitle="Mocks only"
```

</Step>

<Step>

```diff 4,7,9
```

```diff 4,8,10
```

</Step>

<Step>

```diff 
```

```diff 
```

</Step>

</CodeSurferColumns>

<Notes>

- 2 tests font exactement mm chose
- Prend truc, ajout, verifie ajoutÃ©
- Dur Contribuer
- Suite 10 tests chacun complÃ¨tement diffÃ©rent
- Comment faire mieux ?

</Notes>   

---


Stick to your guns

<Notes>

- Aka mÃªme type d'objet, mÃªme type de test

</Notes>

---

<CodeSurferColumns>

<Step>

```js subtitle="Service A" showNumbers
test("add() validation passed saves user to database", async () => {
    const db = { add: jest.fn() }
    const validator = { allows: jest.fn() }
    const user = "user"
    const repository = new ProductsRepository(db, validator)
    validator.mockResolvedValue(true)
    
    await repository.add(user)
    
    expect(db.add).toHaveBeenCalledWith("users", user)
}) 
```

```js subtitle="Service B" showNumbers
test("add() validation passed saves product to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const product = "product"
  const repository = new ProductsRepository(db, validator)
  validator.mockResolvedValue(true)

  await repository.add(product)

  expect(db.add).toHaveBeenCalledWith("products", product)
}) 
```

</Step>

</CodeSurferColumns>

<Notes>

- Choisit strategie test et on s'y colle
- Ici test services via mock 

</Notes>

---

<!--
*****************************************************************************
*****************************************************************************
** Expressiveness ğŸ’¯ *********************************************************
*****************************************************************************
*****************************************************************************
-->

# Expressiveness ğŸ’¯

<Notes>

- Manque expressivitÃ© 

<br/>
- Veut test maintenable
- TravaillÃ© structure = capable trouver marque rapidement/nouveau test
- Etape suivant = arriver Ã  comprendre ce qui se passe
- Trouver bon niveau de dÃ©tail pour comprÃ©hension rapide
- Mettre en valeur ce qui importance dans test
- Cacher le reste

</Notes>

--- 

<!--
****************************
****************************
** ğŸ‘ƒ LOST IN DETAILS
****************************
****************************
-->

ğŸ‘ƒ: Lost in details (ğŸ“šğŸ¤”)

---

<CodeSurfer>

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 12:17 showNumbers
```

```diff 7,12:14 showNumbers 
```

```js showNumbers 
const type = (target, value, page) => {
  const input = page.getByLabelText(target)
  fireEvent.change(input, {
      target: { value },
  })
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 1[30:34]
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    return {...page, type}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 25
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

  
    return {...page, type, submit}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 31
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```diff 30:33
```

```diff 28 
```

```diff 30:31 
```

```diff 32:33
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue()

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    when(login(credentials)).mockResolvedValue()
    
    page.type(/email/i, credentials.email )
    page.type(/password/i, credentials.password )
    page.submit(/login/i)
    page.waitForPendingPromisesToComplete()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
const customRender = (component) => {
    const page = render(component)

    const type = (target, value) => {
      const input = page.getByLabelText(target)
      fireEvent.change(input, {
        target: { value },
      })
    }
  
    const submit = (target) => {
      const element = page.getByRole("button", { name: /login/i } )
      fireEvent.submit(element)
    }

    const waitForPendingPromisesToComplete = () => new Promise(resolve => process.nextTick(resolve))

  
    return {...page, type, submit, waitForPendingPromisesToComplete}
}

const renderLoginPage = () => {
  const page = customRender(<LoginPage />)
  
  const allowLoginFor = (credentials) => when(login(credentials)).mockResolvedValue()

  const fillInLoginForm = (credentials) => {
      page.type(/email/i, credentials.email )
      page.type(/password/i, credentials.password )
  }

  const login = async () => {
    page.submit(/login/i)
    await page.waitForPendingPromisesToComplete()
  }

  return {...page, allowLoginFor, fillInLoginForm, login}
}

test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</CodeSurfer>

<Notes>

- 5 sec to tell me what this is doing
- CompliquÃ© alors que peu de lignes
- PiÃ¨ces bas niveau cachent concept global
- How can we make that better ?

<br/>

- Framework is not for you
- Compose low level pieces into helpers
- Create page/item specific helpers to match domain
- Create interactor/page obejct

</Notes>

---

What, not how

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 7:17 subtitle="Before" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = render(<LoginPage />)
    const emailInput = page.getByLabelText(/email/i)
    const passwordInput = page.getByLabelText(/password/i)
    const submitButton = page.getByRole("button", { name: /login/i })
    when(login(credentials)).mockResolvedValue()
    
    fireEvent.change(emailInput, {
        target: { value: credentials.email },
    })
    fireEvent.change(passwordInput, { target: { value: credentials.password } })
    fireEvent.submit(submitButton)
    await new Promise(resolve => process.nextTick(resolve))
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 6:10 subtitle="After" 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = customRender(<LoginPage />)
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm( credentials )
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Easy to understand
- Domain terms
- Centralized knowledge (bonus)

</Notes>

--- 

<!--
****************************
****************************
** ğŸ‘ƒ SUSPICIOUS VALUES
****************************
****************************
-->

ğŸ‘ƒ: Suspicious values (ğŸ‘®â€â™‚ï¸ğŸ“¦)

<Notes>

- Valeurs suspectes

</Notes>

---

<CodeSurfer>

```js showNumbers
const count = 2
```

```js showNumbers
const date = "20/03/2018"
```

```js showNumbers 3:4 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers
    const route = WHATEVER
    const service = new SomeService(route)

    service.methodThatDoesntUseRoute()
```

</CodeSurfer>


<Notes>

- Why 2, why not 1
- And why not 0
- Whay "20/03/2018" why not 21st ?
- Does it really have to be a valid email ?
- If data shape doesn't matter, show it (credentials.email)
- If value doesn't matter at all, show it (WHATEVER) 

</Notes>

---

Make the unimportant obviously unimportant

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "brucewayne@wayneenterprises.com",
       password: "imbatman",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

```js showNumbers 2:5
test("<LoginPage/>", async () => {
    const credentials = {
       email: "credentials.email",
       password: "credentials.password",
    }
    const page = renderLoginPage()
    page.allowLoginFor(credentials)
    
    page.fillInLoginForm(credentials)
    await page.login()
    
    expect(navigate).toHaveBeenCalledWith("/")
})
```

</Step>

</CodeSurferColumns>

<Notes>

- Clear that the value shape doesn't matter for this test
- If expectation on value passing, you'll get a better message (tracer object)

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ EVERYTHING BOLD
****************************
****************************
-->

ğŸ‘ƒ: Everything bold (ğŸŒğŸ‘¨â€ğŸ¦²)

---

<CodeSurfer>

```js showNumbers
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 2:7
```

```diff 9
```

```diff
```

```js showNumbers subtitle="Factory"
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 11:14
const makeUser = (overrides) => ({
    firstname: "user.firstname",
    lastname: "user.lastname",
    email: "user.email",
    password: "user.password",
    ldap: "user.ldap",
  ...overrides
})

test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```diff 12:13
```

```js showNumbers subtitle="Named factory"
test("Valiation success adds user to repository", () => {
    const user =  makeUser.approvedByIdentity()
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</CodeSurfer>

<Notes>

- What in this user makes this test pass/fail
- I see a validator, so there's probably something going on
- I should be able to tell what
- How can we make that more obvious

</Notes>

---

Highlight what matters

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2:8
test("Valiation success adds user to repository", () => {
    const user =  {
      firstname: "Bruce",
      lastname: "Wayne",
      email: "brucewayne@wayneenterprises.com",
      password: "admmin",
      ldap: "1234"
    }
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** ğŸ‘ƒ Duplicate naming
****************************
****************************
-->

ğŸ‘ƒ: Duplicate naming (ğŸ‘¶ğŸ‘¶)

---

<CodeSurfer>

```js showNumbers
// Calls do something
doSomething()
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const user =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 2:5
test("Valiation success adds user to repository", () => {
    const identityApprovedUser =  makeUser({
      email: "brucewayne@wayneenterprises.com",
      ldap: "1234"
    })
    const validator = new IdentityValidator()
    const repository = new UserRepository(validator) 

    repository.add(user)

    expect(repository.all().first()).toMatchObject(user)
})
```

```js showNumbers 
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```diff 2:7
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</CodeSurfer>

---

Put naming to work

--- 

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers 2[11:16],5[11:16],16
test("Matching user in db returns match", async () => {
    const user1 =  makeUser({
      ldap: "user_1_ldap"
    })
    const user2 = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", user1)
    db.add("users", user2)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(user1)
})
```

```js showNumbers 2[11:23],5[11:25],16
test("Matching user in db returns match", async () => {
    const matchingUser =  makeUser({
      ldap: "user_1_ldap"
    })
    const nonMatchingUser = makeUser({
      ldap: "user_2_ldap"
    })  
    const db = new Db()
    const repository = new UserRepository() 

    db.add("users", matchingUser)
    db.add("users", nonMatchingUser)

    const found = await repository.get({ldap: user1.ldap})

    expect(found).toMatchObject(matchingUser)
})
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** ğŸ‘ƒ MYSTERY GUEST
****************************
****************************
-->

ğŸ‘ƒ: Mystery guest (ğŸ‘»ğŸ)

<Notes>

- L'invitÃ© mystÃ¨re

</Notes>

---


<CodeSurfer>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```diff 5[40:45]
```

```js
// fixtures/db/users.json
[
  {
    name: "John"
    // ...other props
  },
  // ...other users 
]
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

```diff 2:3
```

```diff 7:8
```

```diff 11[10:21,28:41]
```

</CodeSurfer>


<Notes>

- Check rÃ©cupÃ¨re premier item dans table
- The fuck did john come from ?!
- Qq'un forcement changer propriÃ©tÃ© et tout casser
- Cas ou mutation fixtures dans appli legacy -> 3 jours debug

<br/>

- Assume DB starts empty + reset
- On sait ou vient nom
- controle donnÃ©e

</Notes>

---

Control your data

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Returns first item in table`, async () => {
  const db = await bootDb()
  const usersTable = Table.from(db.get("users"))

  expect(usersTable.first().name).toBe("John")
})
```

```js showNumbers
test(`Returns first item in table`, async () => {
  const firstUser = makeUser({name: "first_user"})
  const secondUser = makeUser({name: "second_user"})
  const usersDb = (await bootDb()).get("users")
  const usersTable = Table.from(usersDb)

  db.add(firstUser)
  db.add(secondUser)
  const result = usersTable.first()

  expect(result.name).toBe(firstUser.name)
})
```

</Step>


<Step>

```diff 4
```

```diff 2:11
```

</Step>

<Step>

```diff 5[40:46]
```

```diff 2,11[28:42]
```

</Step>

</CodeSurferColumns>

<Notes>

- Plus long
- Mais pas risque intervention divine
- Controle mes donnÃ©es
- Peut tracer d'ou vient valeur attendue

</Notes>

---

Feedback ğŸ‘Œ 

<Notes>

- When fail, in ci/during refactor 
- Don't want to waste time understanding failure
- Failure should be expressive enough to tell you clearly what was expected and what happened
- Otherwise, time lost 
- Like undefined is not a function
- True, but I still have no clue what the problem is
- Failures should give you clues, breadcrumbs on the path to solving a bug
see justin searls

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ NAN
****************************
****************************
-->

ğŸ‘ƒ: Not a number (ğŸ°)

<Notes>

- Ever had that error
- Not quite useful right 
- Like undefined is not a function
- True, but I still have no clue what the problem is

</Notes>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToBe actual={5} expected={0} />
</TestReport>

---

<CodeSurfer>

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string).length).toBe(5)
})
```

```js showNumbers 3
test("chars() returns every char in string", () => {
  // ...stuff
  expect(chars(string)).toHaveLength(5)
})
```

</CodeSurfer>

---

<TestReport name="chars() returns every char in string">
    <Matchers.ToHaveLength actual={0} expected={10} passed={[]} />
</TestReport>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBe actual={false} expected={true} />
</TestReport>

---

<CodeSurfer>

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button.disabled).toBe(true)
})
```

```js showNumbers 3
test("Cannot re-submit form until post completion", () => {
  // ...stuff
  expect(button).toBeDisabled()
})
```

</CodeSurfer>

---

<TestReport name="Cannot re-submit form until post completion">
    <Matchers.ToBeDisabled />
</TestReport>

---

Leverage matchers

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```bash 
ğŸ›‘ Fail: "chars() returns every char in string"
        
         Error: expected( 0 ).toBe( 5 ) 
```

```bash 
ğŸ›‘ Fail: "chars() returns every char in string"
        
         Error: expect(received).toHaveLength(expected)
         
         Expected length: 10
         Received length: 0
         Received array:  []
```

</Step>

</CodeSurferColumns>

---

<!--
****************************
****************************
** ğŸ‘ƒ Memory dump
****************************
****************************
-->

ğŸ‘ƒ: Memory dump (ğŸ§ ğŸ—‘)

<Notes>


</Notes>

---

<CodeSurfer>

```bash
ğŸ›‘ Fail: "Returns users sorted by id descending"
        Error: expect(received).toEqual(expected) // deep equality
        
        - Expected
        + Received
        
        @@ -4,11 +4,11 @@
                "city": "user.address.city",
                "street": "user.address.city",
              },
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
        -     "id": 3,
        +     "id": 1,
              "lastname": "user.lastname",
            },
            Object {
              "address": Object {
                "city": "user.address.city",
        @@ -24,9 +24,9 @@
                "city": "user.address.city",
                "street": "user.address.city",
              },
              "birthdate": "user.birthdate",
              "firstname": "user.firstname",
        -     "id": 1,
        +     "id": 3,
              "lastname": "user.lastname",
            },
          ]
```

```js showNumbers
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users)

  expect(result).toEqual([user3, user2, user1])
})
```

```js showNumbers 
test(`Orders users by id descending`, () => {
  // ...stuff

  const result = orderUsers(users).map(prop("id"))
  
  expect(result).toEqual([3, 2, 1])
})
```

```diff 4[35:51],6[26:35]
```

```bash
ğŸ›‘ Fail: "Returns users sorted by id descending"
        Error: expect(received).toEqual(expected) // deep equality
        
        - Expected
        + Received
        
          Array [
        -   3,
        -   2,
            1,
        +   2,
        +   3,
          ]
```

```bash
ğŸ›‘ Fail: "Gets user by id"
        Error: expect(received).toBe(expected) // Object.is equality
        
        - Expected
        + Received
        
        @@ -2,9 +2,9 @@
            "address": Object {
              "city": "user.address.city",
              "street": "user.address.city",
            },
            "birthdate": "user.birthdate",
        -   "firstname": "John",
        -   "id": 2,
        +   "firstname": "Bob",
        +   "id": 1,
            "lastname": "user.lastname",
          }
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result).toBe(user2)
})
```

```js
test(`Gets user by id`, async () => {
    // ...stuff

    const result = await repository.get(user2.id)

    expect(result.firstname).toBe(user2.firstname)
})
```

```bash
ğŸ›‘ Fail: "Gets user by id"
        Error: expect(received).toBe(expected) // Object.is equality
        
        Expected: "John"
        Received: "Bob"
```

</CodeSurfer>

---

<!--
****************************
****************************
** ğŸ‘ƒ TRACE FAIL
****************************
****************************
-->

ğŸ‘ƒ: Trace fail (ğŸ—ºğŸ˜¢)

<Notes>

- You just want to test delegaton
- That something has been passed to something else

</Notes>

---

<CodeSurfer>

```bash
ğŸ›‘ Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: {"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}
        Received: undefined
```

```js 2,6,8
test(`Saves user in database c`, async () => {
    const user = withDescription(makeUser(), "user")
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```js
test(`Saves user in database c`, async () => {
    const user = "user"
    const db = { add: jest.fn() }
    const repository = new UserRepository(db)
    
    await repository.create(user)
    
    expect(db.add).toHaveBeenCalledWith(user)
})
```

```bash
ğŸ›‘ Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: "user"
        Received: undefined
```

</CodeSurfer>

---

Use placeholders

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```bash
ğŸ›‘ Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: {"address": {"city": "address.city", "street": "address.city"}, "birthdate": "birthdate", "firstname": "firstname", "lastname": "lastname"}
        Received: undefined
```

```bash
ğŸ›‘ Fail: "Saves user to database"
        Error: expect(jest.fn()).toHaveBeenCalledWith(...expected)
        
        Expected: "user"
        Received: undefined
```

</Step>

</CodeSurferColumns>

---

<EmojiSlide caption="Flexibility">ğŸ¤¸â€</EmojiSlide>

<Notes>

make test xp easy
tests shouldn't break unless behavior changed
tests shouldn't break because a collaborator broke only break for relevant reasons
shouldn't feel like dying because you're adding one param to the constructor and have to update 15 tests
shouldn't break because another part of the spec for this method has changed (objectMatchig)

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ THE CREEP
****************************
****************************
-->

<EmojiSlide caption="The creep">ğŸ”ğŸ˜</EmojiSlide>  

---


<CodeSurfer>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```diff 3
```

```diff 7
```

```diff 5[12:19]
```

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</CodeSurfer>
<Notes>

- Checks state loading once started fetching page data

<br/>

- This is a view but
- Assertion on internal state
- Via private method 
- Fragile: Will break on refactor of state/method
- Not what we care about (aka showing a loader)

<br/>

- Test via public api, here, view
- rename test

</Notes>

---

Test it the way you'll use it

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Switches to loading state on data fetch`, ( ) => {
  const page = createComponent(SomePageComponent)
  const instance = page.getComponentInstance()
    
  instance._getData()

  expect(instance.loading).toBe(true)
})
```

```js showNumbers
test(`Displays a loader on page refresh`, ( ) => {
  const page = createComponent(SomePageComponent)
  
  page.click(/refresh/i)

  expect(page).toHaveText("Loading...")
})
```

</Step>


<Step>

```diff 3[25:44],5[12:19],7[10:25]
```

```diff 4[8:12],6[16:25]
```

</Step>

<Step>

```diff 1[7:45]
```

```diff 1[7:39]
```

</Step>

</CodeSurferColumns>


<Notes>

- Language totally different (instance, getData vs click, hasText)
- Protected from refactor
- Actually tests what matters
- Test name matches spec

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ Overspecified
****************************
****************************
-->

<EmojiSlide caption="Overspecified">ğŸ“šğŸ˜“</EmojiSlide>

---

<CodeSurfer>

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: `"Invalid email" is not a valid email`
    }, 
    count: 1
  })
})
```

```diff 9:14
```

```diff 11[14:52]
```

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: expect.any(String)
    }, 
    count: 1
  })
})
```

```diff 13
```

```js 9:13
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toMatchObject({
    errors: {
      email: expect.any(String)
    }
  })
})
```

</CodeSurfer>

<Notes>

- Verifies validation report matches expectations

<br/>

- Only care about shape of error
- Yet assertion on everything
- What if new key in report/rename count to total
- Breaks for unrelated reasons
- Depends on email validation msg

<br/>

comment faire mieux
- Don't depend on external obj behavior (email)
- Only assert on part that matters, ignore the rest

nom refactor
B/A

</Notes>

---

Assert only on what matters to the test

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toEqual({
    errors: {
      email: `"Invalid email" is not a valid email`
    }, 
    count: 1
  })
})
```

```js showNumbers
test(`Merges all errors under "error" key`, () => {
  const validationSchema = {
    email: Validators.email(),
  } 
  const validate = Validator.from(validationSchema)

  const report = validate({email: "invalid_email"})
  
  expect(report).toMatchObject({
    errors: {
      email: expect.any(String)
    }
  })
})
```

</Step>

<Step>

```diff 6
```

```diff 9[18:32],10:13
```

</Step>

</CodeSurferColumns>


<Notes>

- PrÃ©cisÃ© assertions
- EnlevÃ© dÃ©pendance comportement email
- Peut changer forme report sans risque
- Attention matcher permissif, si vous attendiez clÃ©

</Notes>

---

<!--
****************************
****************************
** ğŸ‘ƒ REDUNDANT COVERAGE
****************************
****************************
-->

<EmojiSlide caption="Redundant coverage">
ğŸ™ˆğŸ™ˆ
</EmojiSlide>

---

<CodeSurfer>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```diff 3
```

```diff 2:4
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</CodeSurfer>

<Notes>

- Checks valid user added to db

<br/>

- DÃ©pend des rÃ¨gles validation identity
- Probablement d'un lien db avec le ldap et l'ident
- Breaks if identity changes

<br/>

- CrÃ©ation frontiere/sÃ©paration interieur/exterieur (collabs)
- Mock validator
- Remove dependency on user
- Remove dependency on db

</Notes>

---

Enforce boundaries

---

<CodeSurferColumns {...splitCodeSampleProps}>

<Step>

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = await bootDb()
  const validator = new IdentityValidator()
  const user = makeUser({ ldap: 1234 })
  const repository = new UserRepository(db, validator)

  await repository.add(user)

  expect(await db.get("users").first()).toMatchObject(user)
})
```

```js showNumbers
test("add() validation passed saves user to database", async () => {
  const db = { add: jest.fn() }
  const validator = { allows: jest.fn() }
  const user = "user"
  const repository = new UserRepository(db, validator)
  when(validator.allows(user)).resolve(true)
  
  await repository.add(user)

  expect(db.add).toHaveBeenCalledWith("users", user)
})
```

</Step>

<Step>

```diff 2,3,4
```

```diff 
```

</Step>

<Step>

```diff 
```

```diff 2,3,4
```

</Step>

<Step>

```diff 
```

```diff 6
```

</Step>

</CodeSurferColumns>

<Notes>

- ImposÃ© limites
- Clair que si bug c'est pas dans les collabs
- Small debug area
- Controle collabs, pas besoin trouver ldap invalide
- Plus compliquÃ© Ã  mairiser

</Notes>



<!--

desc
pb
how better ?
name refactor
B/A commentarytradeofs evaluation
-->
